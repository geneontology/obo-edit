package GOBO::Indexes::StatementIndexHelper;
use Moose;
use Carp;

use Data::Dumper;

use Moose::Util::TypeConstraints;
use GOBO::Statement;
use GOBO::LinkStatement;
use GOBO::Annotation;
use GOBO::Node;
use GOBO::TermNode;
use GOBO::RelationNode;
use GOBO::Indexes::StatementRefIndex;
use GOBO::Indexes::StatementObjectIndex;
use GOBO::ClassExpression;

use Carp qw(cluck);

#around qr/\S+/ => sub { my $orig = shift; my $self = shift; my $m_name = Sub::Identify::sub_name($orig); print STDERR "running " . ref($self) . "->" . $m_name . "\n" if $ENV{VERBOSE}; $self->$orig(@_); };

type 'GOBO::Indexes::StatementIx' => where { $_->isa('GOBO::Indexes::StatementRefIndex') || $_->isa('GOBO::Indexes::StatementObjectIndex') };

has 'indexes' => (
	is => 'rw',
	isa => 'HashRef[GOBO::Indexes::StatementIx]',
	traits=>['Hash'],
	handles => {
		get_statement_ix => 'get',
		add_statement_ix => 'accessor',
		remove_statement_ix => 'delete',
		exists_statement_ix => 'exists',

		get_statement_ix_h => 'elements',
		set_statement_ix_h => 'set',
		clear_statement_ix_h => 'clear',

		get_statement_ix_h_names => 'keys',
		get_statement_ix_h_values => 'values',

	},
	builder=>'_create_ix_h',
#	default=>sub{{}},
);

has 'reserved_index_names' => ( is=>'ro', isa=>'ArrayRef[Str]', default=> sub { [ qw(statements edges ontology_links annotations) ] } );

around qw(add_statement_ix remove_statement_ix) => sub {
	my $method = shift;
	my $self = shift;
	if (grep { $_[0] eq $_ } @{$self->reserved_index_names})
	{	warn "The index $_[0] is automatically generated. Method not performed!";
	}
	else
	{	$self->$method(@_);
	}
};


sub _create_ix_h {
	return
	{	edges => new GOBO::Indexes::StatementRefIndex(),
		ontology_links => new GOBO::Indexes::StatementRefIndex(),
		annotations => new GOBO::Indexes::StatementRefIndex(),
		statements => new GOBO::Indexes::StatementObjectIndex(),
	};
}


=head2 sync_statement_indexes

 input:  self
 output: self, but with the indexes beautifully synchronised!

=cut

sub sync_statement_indexes {
	my $self = shift;
	my $all = $self->get_statement_ix_by_name('statements')->get_all_statements;
	my $add_h;
	foreach my $s (@$all)
	{	map { push @{$add_h->{$_}}, \$s } @{$self->_get_statement_type( $s )};
	}
	if ($add_h)
	{
		map {
			$self->clear_all_statements_in_ix($_);
			$self->add_statements_to_ix( ix => $_, statements => $add_h->{$_} )
		} keys %$add_h;
	}
}


=head2 duplicate_statement_ix

Create a duplicate of a statement index

 input:  $index_to_copy_from
         $index_to_copy_to
 output: graph with the new index

Warning: if $index_to_copy_to already exists, any content will be overwritten

=cut

sub duplicate_statement_ix {
	my $self = shift;
	my ($from, $to) = ( shift(), shift() );
	if (grep { $to eq $_ } @{$self->reserved_index_names})
	{	warn "The name $to is reserved for the autogenerated indexes. Please choose another name";
		return undef;
	}
	my $from_ix = $self->get_statement_ix_by_name($from);
	if (! $from_ix)
	{	warn "Index $from does not exist! Aborting.";
		return undef;
	}

	my $to_ix = new GOBO::Indexes::StatementRefIndex;

	foreach my $ix qw( ixN ixT )
	{	foreach my $t (keys %{$from_ix->$ix})
		{	#print STDERR "t = $t\n";
			map { push @{$to_ix->$ix->{$t}}, $_ } @{$from_ix->$ix->{$t}};
		}
	}
	$self->add_statement_ix($to => $to_ix);
}

sub statements {
	my $self = shift;
	if (@_)
	{	$self->clear_all_statements;
		$self->add_statements(@_);
	}
	return $self->get_all_statements_in_ix('statements', 1);
}

sub edges {
	my $self = shift;
	if (@_)
	{	$self->clear_all_edges;
		$self->add_statements(@_);
	}
	return $self->get_all_statements_in_ix('edges', 1);
}

sub ontology_links {
	my $self = shift;
	if (@_)
	{	$self->clear_all_ontology_links;
		$self->add_statements(@_);
	}
	return $self->get_all_statements_in_ix('ontology_links', 1);
}

sub annotations {
	my $self = shift;
	if (@_)
	{	$self->clear_all_annotations;
		$self->add_statements(@_);
	}
	return $self->get_all_statements_in_ix('annotations', 1);
}

=head2 get_all_statements_in_ix

Get an arrayref of all statements in index $ix_name

 input:  $ix_name
 output: arrayref of all statements in that index

=cut

sub get_all_statements_in_ix {
	my $self = shift;
	if ($_[0] eq 'ix' & defined $_[1])
	{	shift;
	}
	my $ix_name = shift;
	my $ix = $self->get_statement_ix_by_name($ix_name, shift);
	return undef unless $ix;
#	return $ix->get_all_statements;
	my $stt = $ix->get_all_statements;
	return [] unless $stt && @$stt;

	## this sorts the statements
	return [ map { $_->[1] }
	sort { $a->[0] cmp $b->[0] }
	map { my $temp = join "\0",
		$_->node->id,
		$_->can('target') && defined $_->target ? $_->target->id : "",
		$_->can('relation') && defined $_->relation ? $_->relation->id : "";
		$_ = [ $temp, $_ ]; }
	@$stt ];
}


=head2 get_statement_ix_by_name

Get an index by specifying its name

 input:  $ix_name
         $boolean  ## optional; will create the index if it does not exist
 output: the index (if it exists; it may be empty)

=cut

sub get_statement_ix_by_name {
	my $self = shift;
	my $name = shift;
	my $create_if_does_not_exist = shift;
	return unless $name;

#	print STDERR "Looking for $name...\n";

	return $self->get_statement_ix( $name ) if $self->exists_statement_ix( $name );

	return undef unless $create_if_does_not_exist;

	## create a new index otherwise
	$self->add_statement_ix( $name => new GOBO::Indexes::StatementRefIndex() );
	return $self->get_statement_ix( $name );
}


=head2 add_statements_to_ix

Add statements to the graph and into a specific index

 input:  hash of the form
         ix => $ix_name,
         statements => [ $statement, $statement, $statement ... ]
 output: statements that have been successfully added to the graph
         these will appear in the main statement index and any other appropriate
         indexes, including $ix_name

=cut

sub add_statements_to_ix {
	my $self = shift;
	my %args = (
		ix => 'statements',
		%{$self->_check_args(@_)}
	);

	if (! $args{ix} || ! $args{statements})
	{	warn "Missing ix_name or statements for add_statements_to_ix!";
		return;
	}

	my $index;
	if (! grep { $_ eq $args{ix} } @{$self->reserved_index_names})
	{	$index = $self->get_statement_ix_by_name($args{ix}, 1);
	}

	## add the statements to the main index
	my $ref_arr = $self->get_statement_ix_by_name('statements')->get_statement_refs(statements=>$args{statements}, add=>1);

	my $add_h;
	## see if we should add these statements to our stt indexes
	foreach my $r (@$ref_arr)
	{	map { push @{$add_h->{$_}}, $r->{ref} } @{$self->_get_statement_type( ${$r->{ref}} ) };
#		map { push @{$add_h->{$_}}, $r->{ref} } @{$r->{ix}} if $r->{ix};
	}

	if ($add_h)
	{	map { $self->get_statement_ix_by_name($_,1)->add_statements( $add_h->{$_} ) } keys %$add_h;
	}

	if ($index)
	{	## add the statements to the specific index now
		return $index->add_statements( [ map { $_->{ref} } @$ref_arr ] );
	}
	else
	{	return [ map { ${$_->{ref}} } @$ref_arr ];
	}
}

*add_statements = \&add_statements_to_ix;
*add_statement = \&add_statements_to_ix;
*add_statement_to_ix = \&add_statements_to_ix;
*add_edges = \&add_statements_to_ix;
*add_ontology_links = \&add_statements_to_ix;
*add_annotations = \&add_statements_to_ix;
*add_edge = \&add_statements_to_ix;
*add_ontology_link = \&add_statements_to_ix;
*add_annotation = \&add_statements_to_ix;


=head2 remove_statements

Globally remove a statement (or statements)

 input:  hash of the form
         statements => [ $statement, $statement, $statement ... ]
 output: none; statements will be removed from graph

=cut

sub remove_statements {
	my $self = shift;
	my %args = %{$self->_check_args(@_)};
	if (! $args{statements} || scalar @{$args{statements}} == 0)
	{	warn "Missing statements for " . (caller(0))[3] . "!";
		return;
	}


	## remove the statements from the main index
	my $ref_arr = $self->get_statement_ix_by_name('statements')->get_statement_refs(statements=>$args{statements}, remove=>1);

#	print STDERR "ref_arr: " . join("\n", map { Dumper($_) } @$ref_arr ) . "\n\n";

	my %statements = $self->get_statement_ix_h;
	foreach (keys %statements)
	{	next if $_ eq 'statements';
		#print STDERR "removing $ref_arr from $_\n";
		$statements{$_}->remove_statements($ref_arr);
	}
	return;
}

*remove_statement = \&remove_statements;
*remove_annotations = \&remove_statements;
*remove_ontology_links = \&remove_statements;
*remove_edges = \&remove_statements;
*remove_annotation = \&remove_statements;
*remove_ontology_link = \&remove_statements;
*remove_edge = \&remove_statements;


=head2 remove_statements_from_ix

Remove a statement from a specific index. ONLY works for custom indexes, does
not remove statements from the autogenerated indexes (statements, edges,
ontology_links and annotations).

 input:  hash of the form
         statements => [ $statement, $statement, $statement ... ]
         ix => $ix_name
 output: none; statements will be removed from that index

=cut

sub remove_statements_from_ix {
	my $self = shift;
	my %args = %{$self->_check_args(@_)};

#	print STDERR "starting remove_statements_from_ix...\n";

	if (! $args{ix} || ! $args{statements})
	{	warn "Missing ix_name or statements for " . (caller(0))[3] . "!";
		return;
	}

	if (grep { $_ eq $args{ix} } @{$self->reserved_index_names} )
	{	return $self->remove_statements(%args);
	}

	my $index = $self->get_statement_ix_by_name($args{ix});
	return if ! $index;

	## get the statements from the main index
	my $ref_arr = $self->get_statement_ix_by_name('statements')->get_statement_refs(statements=>$args{statements});

	## remove the statements from the specific index now
#	return $index->remove_statements( [ map { ${$_->{ref}} } @$ref_arr ] );
	return $index->remove_statements( $ref_arr );
}

*remove_statement_from_ix = \&remove_statements_from_ix;


=head2 remove_statements_from_ix_by_id

Remove all statements with a particular node or target ID from an index

 input:  hash in the form
          ix => $ix_name
          node_id => $n_id OR target_id => $t_id
 output: nowt

=cut

sub remove_statements_from_ix_by_id {
	my $self = shift;
	my %args = (@_);

	if (! $args{ix} || ( ! $args{node_id} && ! $args{target_id}
#	&& ! $args{node} && ! $args{target}
	) )
	{	warn "Missing ix_name or ID for " . (caller(0))[3] . "!";
		return;
	}

	if (grep { $_ eq $args{ix} } @{$self->reserved_index_names} )
	{	return $self->remove_statements_by_id(%args);
	}

	my $ix = $self->get_statement_ix_by_name($args{ix});
	return unless $ix;
	$ix->remove_statements_by_id( %args );
}


=head2 remove_statements_by_id

Remove all statements with a particular node or target ID from the graph

 input:  hash in the form
          node_id => $n_id OR target_id => $t_id
 output: nowt

=cut

sub remove_statements_by_id {
	my $self = shift;
	my %args = (@_);

	if (! $args{node_id} && ! $args{target_id}
#	&& ! $args{node} && ! $args{target}
	)
	{	warn "Missing ix_name or ID for " . (caller(0))[3] . "!";
		return;
	}

	my %statements = $self->get_statement_ix_h;
	foreach my $ix (keys %statements)
	{	#next if $ix eq 'statements';
		$statements{$ix}->remove_statements_by_id( %args );
	}
}


=head2 clear_all_statements_in_ix

Remove all statements from an index. If the index specified is one of the
'special' indexes--statements, edges, ontology_links or annotations--the
statements will be deleted from the graph completely.

 input:  $ix_name
 output: the cleared index

=cut

sub clear_all_statements_in_ix {
	my $self = shift;
	my $ix = shift;
	if (grep { $ix eq $_ } @{$self->reserved_index_names})
	{	my $stt = $self->get_all_statements_in_ix($ix);
		return $self->remove_statements( statements => $stt );
	}

	warn "Index $ix does not exist" && return if ! $self->exists_statement_ix($ix);
	## replace the existing index with a new one
	$self->remove_statement_ix( $ix );
	$self->add_statement_ix( $ix => new GOBO::Indexes::StatementRefIndex );

}

sub clear_all_statements {
	my $self = shift;
	## clear everything and start afresh
	$self->indexes( $self->_create_ix_h );
	return;
}
sub clear_all_edges {
	my $self = shift;
	my $edges = $self->get_all_statements_in_ix('edges');
	$self->remove_statements(statements=>$edges) if $edges && @$edges;
	return;
}
sub clear_all_ontology_links {
	my $self = shift;
	my $links = $self->get_all_statements_in_ix('ontology_links');
	$self->remove_statements(statements=>$links) if $links && @$links;
	return;
}
sub clear_all_annotations {
	my $self = shift;
	my $assocs = $self->get_all_statements_in_ix('associations');
	$self->remove_statements(statements=>$assocs) if $assocs && @$assocs;
	return;
}


=head2 statements_in_ix_by_node_id

Get statements in an index by specifying the node ID

 input:  $ix_name, $node_id
 output: arrayref of statements where node->id = $node_id

=cut

sub statements_in_ix_by_node_id {
	my $self = shift;
	my $ix = shift;
	warn "Index $ix does not exist" && return if ! $self->exists_statement_ix($ix);
	return $self->get_statement_ix_by_name($ix)->statements_by_node_id(@_);
}

sub statements_by_node_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('statements',1)->statements_by_node_id(@_);
}
sub edges_by_node_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('edges', 1)->statements_by_node_id(@_);
}
sub ontology_links_by_node_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('ontology_links', 1)->statements_by_node_id(@_);
}
sub annotations_by_node_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('annotations', 1)->statements_by_node_id(@_);
}

=head2 statements_in_ix_by_target_id

Get statements in an index by specifying the target ID

 input:  $ix_name, $target_id
 output: arrayref of statements where target->id = $target_id

=cut


sub statements_in_ix_by_target_id {
	my $self = shift;
	my $ix = shift;
	warn "Index $ix does not exist" && return if ! $self->exists_statement_ix($ix);
	return $self->get_statement_ix_by_name($ix)->statements_by_target_id(@_);
}

sub statements_by_target_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('statements', 1)->statements_by_target_id(@_);
}
sub edges_by_target_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('edges', 1)->statements_by_target_id(@_);
}
sub ontology_links_by_target_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('ontology_links', 1)->statements_by_target_id(@_);
}
sub annotations_by_target_id {
	my $self = shift;
	return $self->get_statement_ix_by_name('annotations', 1)->statements_by_target_id(@_);
}


=head2 statement_ix_node_index

Get an array of the node ids in index $ix_name

 input:  $ix_name
 output: arrayref of node_ids

=cut

sub statement_ix_node_index {
	my $self = shift;
	my $ix = shift;
	if (! $self->exists_statement_ix($ix))
	{	warn "Index $ix does not exist" if $ENV{VERBOSE};
		return [];
	}
	return $self->get_statement_ix_by_name($ix)->statement_node_index;
}

sub statement_node_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('statements',1)->statement_node_index;
}
sub edge_node_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('edges', 1)->statement_node_index;
}
sub ontology_link_node_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('ontology_links', 1)->statement_node_index;
}
sub annotation_node_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('annotations', 1)->statement_node_index;
}


=head2 statement_ix_target_index

Get an array of the target ids in index $ix_name

 input:  $ix_name
 output: arrayref of target_ids

=cut


sub statement_ix_target_index {
	my $self = shift;
	my $ix = shift;
	if (! $self->exists_statement_ix($ix))
	{	warn "Index $ix does not exist" if $ENV{VERBOSE};
		return [];
	}
	return $self->get_statement_ix_by_name($ix)->statement_target_index;
}

sub statement_target_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('statements', 1)->statement_target_index;
}
sub edge_target_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('edges', 1)->statement_target_index;
}
sub ontology_link_target_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('ontology_links', 1)->statement_target_index;
}
sub annotation_target_index {
	my $self = shift;
	return $self->get_statement_ix_by_name('annotations', 1)->statement_target_index;
}


sub _get_statement_type {
	my $self = shift;
	my $s = shift;
	my @types = ();

	## add to the edge index
	if ($s->isa("GOBO::LinkStatement"))
	{
#		print STDERR "looking at " .
#		ref($s->node) . " " . $s->node->id . " --- " .
#		ref($s->relation) . " " . $s->relation->id . " --> " .
#		ref($s->target) . " " . $s->target->id . "\n";

		if ($s->isa("GOBO::Annotation"))
		{	@types = qw( annotations edges );
		}
		## add to ontology_links
		elsif ($s->node->isa("GOBO::TermNode") && $s->target->isa("GOBO::TermNode"))
		{	@types = qw( ontology_links edges );
		}
		else
		{	@types = qw( edges );
		}
	}
	return \@types;
}


=head2 get_matching_statements

 input:  hash with one or more of node, relation and target defined
 output: arrayref of matching statements or []

=cut

sub get_matching_statements {
	my $self = shift;

#	print STDERR "\@_: " . join(", ", @_) . "\n\n" if $ENV{VERBOSE};

	my %args = (
		ix => 'statements',
		@_
	);

#	print STDERR "args: " . Dumper( \%args ) . "\n" if $ENV{VERBOSE};

	if (! $self->get_statement_ix_by_name($args{ix}) )
	{	#cluck
		#warn
		#"Statement ix $args{ix} does not exist!";
		return [];
	}

	foreach my $x qw(node relation target)
	{	if ($args{$x})
		{	# make sure we don't have an id
			if (! ref $args{$x})
			{	$args{ $x . "_id"} = $args{$x};
				delete $args{$x};
				next;
			}
			$args{ $x . "_id" } = $args{$x}->id;
		}
	}

	my $ix = $self->get_statement_ix_by_name($args{ix});
	my @sl;
	if ($args{node_id})
	{	@sl = @{$ix->statements_by_node_id( $args{node_id} )};
		if ($args{target_id})
		{	@sl = grep { $_->target->id eq $args{target_id} } @sl;
		}
		if ($args{relation_id})
		{	@sl = grep { $_->relation->id eq $args{relation_id} } @sl;
		}
	}
	elsif ($args{target_id})
	{	@sl = @{$ix->statements_by_target_id( $args{target_id} )};
		if ($args{relation_id})
		{	@sl = grep { $_->relation->id eq $args{relation_id} } @sl;
		}
	}
	elsif ($args{relation_id})
	{	@sl = grep { $_->relation->id eq $args{relation_id} } @{$ix->get_all_statements};
	}
#	else
#	{	warn "No selection criteria found for get_matching_statements!\n";
#		return [];
#	}

#	return [] if ! @sl;

	# if x = a AND r(b), then x r b
	if (ref($args{node}) && $args{node}->isa('GOBO::ClassExpression::Intersection')) {
		foreach (@{$args{node}->arguments}) {
			if ($_->isa('GOBO::ClassExpression::RelationalExpression')) {
				push(@sl, new GOBO::LinkStatement(node=>$args{node},relation=>$_->relation,target=>$_->target));
			}
			else {
				push(@sl, new GOBO::LinkStatement(node=>$args{node},relation=>'is_a',target=>$_));
			}
		}
	}

#	if ($args{ix} eq 'inferred_outgoing_ontology_links' && scalar @sl > 0)
#	{	print STDERR "found saved links for " . ( $args{node_id} || $args{target_id} ) . ":\n" . join("\n", @sl) . "\n\n";
#	}

	return \@sl;
}


=head2 get_outgoing_statements_in_ix

Get statements involving a certain $statement->node object
If relation is specified, the results are filtered to include only statements
with that relation

 input:  $node     ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
         $ix_name  ## the name of the index
 output: arrayref of statements matching the criteria


=head2 get_outgoing_statements

 input:  $node     ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->statements

=head2 get_outgoing_edges

 input:  $node     ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->edges

=head2 get_outgoing_ontology_links

 input:  $node     ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->ontology_links

=head2 get_outgoing_annotations

 input:  $node     ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->annotations

=cut

sub get_outgoing_statements_in_ix {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('node', undef, @_);
	return $self->get_matching_statements(%$args);
}

sub get_outgoing_statements {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('node', 'statements', @_);
	return $self->get_matching_statements(%$args);
}
sub get_outgoing_edges {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('node', 'edges', @_);
#	print STDERR "args now: " . Dumper(\%$args) . "\n";
	return $self->get_matching_statements(%$args);
}
sub get_outgoing_ontology_links {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('node', 'ontology_links', @_);
#	print STDERR "args now: " . Dumper(\%$args) . "\n";
	return $self->get_matching_statements(%$args);
}
sub get_outgoing_annotations {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('node', 'annotations', @_);
	return $self->get_matching_statements(%$args);
}


=head2 get_incoming_statements_in_ix

Get statements involving a certain $statement->target object
If relation is specified, the results are filtered to include only statements
with that relation

 input:  $target   ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
         $ix_name  ## the name of the index
 output: arrayref of statements matching the criteria


=head2 get_incoming_statements

 input:  $target   ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->statements

=head2 get_incoming_edges

 input:  $target   ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->edges

=head2 get_incoming_ontology_links

 input:  $target   ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->ontology_links

=head2 get_incoming_annotations

 input:  $target   ## GOBO::Node
         $relation ## GOBO::RelationNode (optional)
 output: arrayref of matching statements from $graph->annotations

=cut


sub get_incoming_statements_in_ix {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('target', undef, @_);
	return $self->get_matching_statements(%$args);
}

sub get_incoming_statements {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('target', 'statements', @_);
	return $self->get_matching_statements(%$args);
}
sub get_incoming_edges {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('target', 'edges', @_);
	return $self->get_matching_statements(%$args);
}
sub get_incoming_ontology_links {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('target', 'ontology_links', @_);
	return $self->get_matching_statements(%$args);
}
sub get_incoming_annotations {
	my $self = shift;
	my $args = $self->_check_args_get_in_out('target', 'annotations', @_);
	return $self->get_matching_statements(%$args);
}



## checks that the arguments are in the correct format
## for the incoming/outgoing statements
sub _check_args_get_in_out {
	my $self = shift;
	return unless @_;
	my ($n_type, $ix) = ( shift, shift );

	my @saved = @_;
	my $l_type;

	my %args;
	if (ref $_[0])
	{	$l_type = "loop 1";
		$args{$n_type} = shift;
		$args{$n_type . "_id"} = $args{$n_type}->id;
		$args{ix} = $ix;
		if (@_)
		{	$args{relation} = $_[0];
			$args{ix} = $_[1] if defined $_[1];
		}
	}
	else
	{	if (scalar @_ % 2 == 0 && grep { $_[0] eq $_ } qw( relation ix node node_id target target_id ) )
		{	$l_type = "loop 2";
			%args = (@_);
			$args{ix} = $ix if ! $args{ix};
		}
		else
		{	$l_type = "loop 3";
			$args{$n_type . "_id"} = shift;
			my $rel = shift;
			if (defined $rel)
			{	if (! ref $rel)
				{	$args{relation_id} = $rel;
				}
				else
				{	$args{relation} = $rel;
				}
			}
			if (@_ && defined $_[0])
			{	$args{ix} = shift;
			}
			else
			{	$args{ix} = $ix if defined $ix;
			}
		}
	}

	if (! $args{ix})
	{
		cluck "No index specified! Args in: $n_type; " . ( $ix || "undef" ) . "; " . join("; ", map { defined $_ 
		? ( ref($_) || 'scalar' ) . " $_" 
		: "undef" } @saved )
		. "\nloop type: $l_type\n";
	
	};

#	print STDERR "args now: " . Dumper(\%args) . "\n\n" if $ENV{VERBOSE};

	return \%args;
}


## check arguments for adding/removing statements
sub _check_args {
	my $self = shift;
	return unless @_;
	my %args;

#	print STDERR "args:\n" . join("\n", map { ref($_) . " $_, " . Dumper($_) } @_ ) . "\n";

	if (ref $_[0] && ref $_[0] eq 'ARRAY')
	{	%args = ( statements => shift(), @_ );
	}
	elsif (ref $_[0] && $_[0]->isa('GOBO::Statement'))
	{	# e.g. $graph->add_statements( statement, statement )
		%args = ( statements => [@_] );
	}
	elsif (! ref $_[0] && ( scalar(@_) % 2 == 0 ) )
	{	my %args = (@_);
		if ($args{statements} && ref $args{statements} ne 'ARRAY')
		{	$args{statements} = [ $args{statements} ];
		}
		return \%args;
	}
	else
	{	%args = (@_);
	}
	return \%args;
}



1;


=head1 NAME

GOBO::Indexes::StatementIndexHelper

=head1 SYNOPSIS

do not use this method directly

=head1 DESCRIPTION

An intelligent object that handles access to the various StatementIndexes belonging
to a Graph.

=head2 TODO

Currently there are 2 indexes, by node (subject) and by target. There
are a limited amount of query options.

Eventually it should support any combination of S-R-T indexing, and
any kind of S-R-T access

We also want a NodeIndex

=head2 Binding to a database

This index is in-memory. It can be extended to be bound to a database
(e.g. the GO Database) by overriding the methods

=cut
