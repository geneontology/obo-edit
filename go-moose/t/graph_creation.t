#use Test;
use Test::More;
use Test::Deep;
use Test::Output;

plan tests => 34;
use strict;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;

use GOBO::Graph;
use GOBO::Indexes::StatementObjectIndex;
use GOBO::Indexes::StatementRefIndex;
use GOBO::Indexes::StatementIndexHelper;

# $ENV{VERBOSE} = 1;
my $obj = new GOBO::Graph;


use GOBO::Statement;
use GOBO::LinkStatement;
use GOBO::NegatedStatement;
use GOBO::Node;
use GOBO::Graph;
use GOBO::Parsers::OBOParserDispatchHash;
use GOBO::Parsers::QuickGAFParser;
use GOBO::Writers::OBOWriter;
use GOBO::DataArray;
use FileHandle;
use Storable qw( dclone );


my $parser = new GOBO::Parsers::OBOParserDispatchHash(file=>"t/data/obo_file.obo");

$parser->parse;

my $g = $parser->graph;

#print STDERR "graph: " . Dumper($g);

#print "Mystery node: " . Dumper($g->noderef(" "));

## create a new graph and check that we can add terms 'n' links 'n' stuff to it
my $new_g = new GOBO::Graph;

foreach (@{$g->terms})
{	$new_g->add_term( $g->noderef($_) );
}

foreach (@{$g->relations})
{	$new_g->add_relation( $g->noderef($_) );
}

$new_g->add_statements( $g->statements );
#foreach (@{$g->links})
#{	$new_g->add_link( $_ );
#}

foreach my $attrib qw( version source provenance date xrefs alt_ids is_anonymous comment declared_subsets property_value_map )
{	$new_g->$attrib( $g->$attrib ) if $g->$attrib;
}

## a bit of a hack... should really be done by parser :S
$g->update_node_label_index;

## test 1
ok( $new_g->isa('GOBO::Graph'), "Checking new_g is a graph" );

foreach (keys %$g)
{	if ($_ eq 'statement_ix_h')
	{	foreach my $x qw(statements ontology_links edges annotations)
		{	if (! is_deeply(
		[ map { $_->[1] } sort { $a->[0] cmp $b->[0] } map { [ $_->as_string, $_ ] } @{$g->$x} ], [ map { $_->[1] } sort { $a->[0] cmp $b->[0] } map { [ $_->as_string, $_ ] } @{$new_g->$x} ], "Checking $x...") )
			{	print "non-matching structures: graph: " . Dumper($g->{$_}) . "\nnew_g: " . Dumper($new_g->{$_});
			}
		}
	}
	else
	{	if (! is_deeply($g->{$_}, $new_g->{$_}, "Checking $_ graph structures..."))
		{	print "non-matching structures: graph: " . $g->{$_}->dump(3) . "\nnew_g: " . $new_g->{$_}->dump(3);
		}
	}
}

$g->duplicate_statement_ix('ontology_links', 'new_ontology_links');

my @ix_names = $g->get_statement_ix_h_names;
ok( grep { $_ eq 'new_ontology_links' } @ix_names , "Checking we have new_ontology_links");
my $links = join ", ", map { $_->[0] } sort { $a->[0] cmp $b->[0] } map { [ $_->as_string, $_ ] } @{$g->get_all_statements_in_ix('ontology_links')};
my $new_l = join ", ", map { $_->[0] } sort { $a->[0] cmp $b->[0] } map { [ $_->as_string, $_ ] } @{$g->get_all_statements_in_ix('new_ontology_links')};

ok( $links eq $new_l, "Checking the contents of new_ontology_links");

$g->duplicate_statement_ix('new_ontology_links', 'more_ontology_links');
my $n_links = scalar @{$g->get_all_statements_in_ix('ontology_links')};
my $e = $g->get_incoming_edges($g->get_term('GO:0000019'));

$g->remove_statement_from_ix(statements => $e, ix=>'new_ontology_links');

ok( scalar @{$g->get_all_statements_in_ix(ix=>'ontology_links')} == scalar @{$g->get_all_statements_in_ix(ix=>'more_ontology_links')} && scalar @{$g->get_all_statements_in_ix(ix=>'more_ontology_links')} == $n_links && $n_links != 0, "Checking that we haven't lost links from more_ontology_links");

ok(scalar @$e != 0, "Checking we removed links");
ok( (scalar @$e) + (scalar @{$g->get_all_statements_in_ix('new_ontology_links')}) == $n_links, "Checking we removed statements from new_ontology_links");

stderr_like( sub { $g->duplicate_statement_ix('ontology_links', 'annotations') }, qr/The name annotations is reserved for the autogenerated indexes/, "Checking we can't create an index called 'annotations'");

stderr_like( sub { $g->remove_statement_ix('ontology_links') }, qr/The index ontology_links is automatically generated. Method not performed/, "Checking we can't delete a reserved ix");

## check some other graph functions at the same time...

## get_annotated_terms
$parser = new GOBO::Parsers::OBOParserDispatchHash(file=>'t/data/tiny_obo.obo', graph => new GOBO::Graph );
$parser->parse;
$g = dclone $parser->graph;
my $g2 = dclone $parser->graph;

## get the GA data
my $gaf_parser = GOBO::Parsers::QuickGAFParser->new(fh=>'t/data/tiny_gaf.gaf');
my $assoc_data = $gaf_parser->parse;

## this file contains the 'annotated_to' and 'annotated_to_NOT' relations
$parser = new GOBO::Parsers::OBOParserDispatchHash(file=>'t/data/annotation_relations.obo',
	graph => new GOBO::Graph,
	body => { parse_only => { typedef => '*' } },
);
$parser->parse;
foreach (@{$parser->graph->relations})
{	$g->add_relation($_);
}
## add to the graph
foreach my $a (keys %{$assoc_data->{by_a}})
{	my $a_node = new GOBO::DataArray( id => $a, data => $assoc_data->{by_a}{$a}{arr} );
	$g->add_node($a_node);
	foreach my $t (@{$assoc_data->{by_a}{$a}{terms}})
	{	next if $t =~ /GO:000000[2468]/;
		## check the term exists in the graph
		next if ! $g->get_term($t);
		my $link = new GOBO::Annotation(node=>$a_node, relation=>$g->get_relation('annotated_to'), target=>$g->get_term($t));
		$g->add_annotation($link);
		if ($t =~ /[37]/)
		{	$g2->add_statement_to_ix(ix=>'special_annotations', statements=>[ $link ]);
		}
		else
		{	$g2->add_annotation($link);
		}
	}
}

#my $t_arr = sort { $a->id cmp $b->id } @{$g->get_annotated_terms};
#my $t2_arr = sort { $a->id cmp $b->id } @{$g2->get_annotated_terms('annotations')};
ok( join("--", sort { $a->id cmp $b->id } @{$g->get_annotated_terms}) eq 'GO:0000001--GO:0000003--GO:0000005--GO:0000007', "Checking links are correct");
ok( join("--", sort { $a->id cmp $b->id } @{$g2->get_annotated_terms('annotations')} ) eq 'GO:0000001--GO:0000003--GO:0000005--GO:0000007', "Checking links are correct");
ok( join("--", sort { $a->id cmp $b->id } @{$g2->get_annotated_terms('special_annotations')} ) eq 'GO:0000003--GO:0000007', "Checking links are correct");

## load up a graph and check some roots.
$parser = new GOBO::Parsers::OBOParserDispatchHash(file=>'t/data/obo_file.obo');
$parser->parse;

## get the root of the graph
$g = $parser->graph;
my $roots = $g->get_roots;
ok( join("\n", @$roots) eq 'GO:0000019', "Checking the root is correct");
$roots = $g->get_connected_roots;
ok( join("\n", @$roots) eq 'GO:0000019', "Checking the connected root");
ok( join("---", sort map { $_->id } @{$g->get_leaves}) eq "GO:0000001---GO:0000002---GO:0000003---GO:0000004---GO:0000005---GO:0000017---GO:0000024", "Checking we have the correct leaves");

my @links = map { $_->as_string } @{$g->ontology_links};
## make a copy of the ontology links
$g->duplicate_statement_ix('ontology_links', 'new_ix');



my @arr = map { $_->as_string } @{ $g->get_outgoing_statements_in_ix('GO:0000008', undef,  'new_ix') };
push @arr, map { $_->as_string } @{ $g->get_incoming_statements_in_ix('GO:0000019', undef, 'new_ix')};
die "Error! Did not find enough ontology links" unless scalar @arr == 5;

## remove some statements
print STDERR "Removing statements:\n" . join("\n", @arr) . "\n\n";
$g->remove_statements_from_ix_by_id( node_id => 'GO:0000008', ix => 'new_ix');
$g->remove_statements_from_ix_by_id( target_id => 'GO:0000019', ix => 'new_ix');

my @all = map { $_->as_string } @{$g->get_all_statements_in_ix('new_ix')};
my @errs;
foreach my $s (@all)
{	push @errs, $s if grep { $s eq $_ } @arr;
}
ok( scalar @errs == 0, "Removed the correct statements" );

@arr = map { $_->as_string } @{ $g->get_outgoing_statements_in_ix('GO:0000008', undef,  'ontology_links') };
push @arr, map { $_->as_string } @{ $g->get_incoming_statements_in_ix('GO:0000019', undef, 'ontology_links')};
die "Error! Did not find enough ontology links" unless scalar @arr == 5;

my @all2 = map { $_->as_string } @{$g->ontology_links};
ok( join("\n", sort @links ) eq join("\n", sort @all2), "Making sure we didn't lose anything valuable");

## remove some statements from 'ontology_links' and 'statements'
$g->remove_statements_from_ix_by_id( node_id => 'GO:0000008', ix => 'ontology_links');
$g->remove_statements_from_ix_by_id( target_id => 'GO:0000019', ix => 'statements');

@all2 = map { $_->as_string } @{$g->get_all_statements_in_ix('ontology_links')};
ok( join("\n", sort @all) eq join("\n", sort @all2), "Checking we lost our statements");

$roots = $g->get_roots;
ok( join("---", sort map { $_->id } @$roots ) eq "GO:0000008---GO:0000017---GO:0000018---GO:0000019---GO:0000021---GO:0000025", "Checking roots");

my $r_arr = $g->get_connected_roots;
ok( join("---", sort map { $_->id } @$r_arr ) eq "GO:0000008---GO:0000018---GO:0000021---GO:0000025", "Checking the connected roots");
## should have GO:0000008, 18, 21, 25

## remove all edges
$g->clear_all_statements;
$r_arr = $g->get_roots;
## there is one obsolete term that won't be included
ok( ( scalar @$r_arr + 1 ) == scalar @{$g->terms}, "Checking we have loadsa roots" );

$r_arr = $g->get_connected_roots;
ok( scalar @$r_arr == 0, "Checking we have no connected roots" );

exit(0);