#!/usr/bin/ruby -w
####
#### Run: ./kappa
####
#### TODO: Still needs to be run from geneontology/go-dev/amigo/testing.
#### TODO: Agents should share cookies...
#### TODO: Randomized input (generate new test files on the fly?).
#### TODO: Still have globals running around (nice for debugging for now)...
####
#### irb:
####    ['pagent.rb', 'amigo.rb', 'aunit.rb', 'kappa'].each{|l| load l }
####
#### command line:
####    ./kappa --url http://localhost/cgi-bin/amigo --data /home/sjcarbon/local/src/svn/geneontology/go-dev/amigo/testing/data --tests /home/sjcarbon/local/src/svn/geneontology/go-dev/amigo/testing/profiles/amigo --output /home/sjcarbon/tmp/kappa
####

require 'getoptlong'
# require 'rdoc/usage'

require 'pagent'
require 'amigo'
require 'aunit'
#require 'amb'
#require 'nondeterminism'

include AmiGO
include AUnit

##
opts = GetoptLong.new(
                      ['--help', '-h', GetoptLong::NO_ARGUMENT],
                      # ['--aconf', '-a', GetoptLong::REQUIRED_ARGUMENT],
                      ['--data', '-d', GetoptLong::REQUIRED_ARGUMENT],
                      ['--tests', '-t', GetoptLong::REQUIRED_ARGUMENT],
                      ['--output', '-o', GetoptLong::REQUIRED_ARGUMENT],
                      ['--url', '-u', GetoptLong::REQUIRED_ARGUMENT]
                      )

## Globals until all of the debugging is done.
# $aconf = './config.json'
$data = './data'
$tests = './profiles/tests' # ? should this be switched on if __FILE__ == $0
$output = '/tmp'
$url = 'http://localhost'
opts.each do |opt, arg|
  case opt
  when '--help'
    ## TODO: 
    # RDoc::usage
    puts "Please see the source code for now for usage and examples."
    Kernel.exit
  when '--data'
    $data = arg
  when '--tests'
    $tests = arg
  when '--output'
    $output = arg
  when '--url'
    $url = arg
  end
end

# ## Make sure that file things are files.
# [$aconf].each do |f|
#   if not File.readable? f
#     raise "file argument not readable: #{f}"
#   end
# end

## Make sure that dir things are directories.
[$data, $tests, $output].each do |d|
  if not File.writable? d
    raise "directory argument not writable: #{d}"
  end
end

##
$log_file = $output +'/'+ 'details.log'
$errors = 0

## Clear output directory of html and png files.
def _clear_output_dir da_dir
  Dir.foreach(da_dir) do |f|
    full_name = da_dir + '/' + f
    if File.exists?(full_name)
      if f =~ /^[0-9]{14}\_.*\.(png|gif|html|json)$/
        # puts "_" + full_name
        File.delete(full_name)
      end
    end
  end
end

## Delete log file.
def _erase_log log_file
  if File.exists?(log_file)
    File.delete(log_file)
    true
  else
    false
  end
end

##
def _ready_dir (dir)
  ## Make sure that there is a directory or something there...
  if File.exists? dir
    if not File.directory? dir or not File.writable? dir
      raise "There is something wrong with an extant #{dir}"
    end
    false
  else
    Dir.mkdir(dir)
    true
  end
end

## 
def _log (line = "???")

  gtime = "[#{Time.now.strftime("%Y%m%d%H%M%S")}]"
  _ready_dir(File.dirname($log_file))
  
    f = File.open($log_file, 'a')
  f.write("#{gtime} #{line}\n")
  f.close
  
  nil
end

###
### TODO: randomly generate input.
###

# $test_map[:random] = proc do

#   ## Get initial page for probing.
#   $t9 = PAgent::HTML.new($te_home_url)

#   ## Create a speciesdb subset using amb.
#   all_sdb = $t9.select_values('term_enrichment_form', 'speciesdb')
#   $sbd_subset = []
#   amb = Amb.new
#   begin
#     a = amb.choose(all_asdb)
#     @a.assert(  )
#         @a.assert( a + b == c )
#         assert( (a < b) && (a + b == c) )
#         solutions.push({:a => a, :b => b, :c => c})
#         @a.search
#       rescue Amb::ExhaustedError
#         #puts "No More Solutions"
#       end

# ## Get large bank of GPs.
# $gp_bank = [];
# ['gp/All_genes',
#  'gp/sc_product_list',
#  'gp/total-genes-MGIMGI.txt'].each do |fname|

#   full_name = $data_home + fname
#   file = File.new(full_name)
#   file.each do |line|
#     $gp_bank.push(line.chomp)
#   end
#   file.close

# end

# ## Shuffle banked gene products...
# shuffled = $gp_bank.sort_by { rand }
# $gp_subset = shuffled.slice(0,100)
# $bggp_subset = shuffled.slice(0,500)

# ## Create form template.
# $random_form_hash = {
#   'form' => 'term_enrichment_form',
#   'multi_select' => {'speciesdb' => ['SGD', 'dictyBase', 'MGI']},
#   'radio' => {'iea' => 'yes'},
#   'field' => {
#     #'request' => 'results',
#     #'force' => 'yes',
#     'cutoff' => '10',
#     'gp_list' => $gp_subset.join(' '),
#     'bggp_list' => $bggp_subset.join(' ')
#   }
# }

# ## Run page.
# $t9.form_from_conf(Conf.new($random_form_hash))
# $t10 = $t9.submit('term_enrichment')

#   ## May have timed out.
#   if ! $t10.nil?

#     ## Run out the visualization from the TE results pages if
#     ## possible.
#     $t11 = $t10.submit('visualize')
#     if ! $t11.nil?
#       puts "got image: " + $t11.dump($output)
#     else
#       puts "random visualize may have timed out"
#     end
#   else
#     puts "random TE may have timed out"
#   end

# end

###
### ...
###

def inspector (runner)
  
  puts "Trying tests: #{runner.id}..."
  _log("Trying tests: #{runner.id}: #{runner.comment}")

  ##
  cleared = false
  begin
    $vpage = PageVerifier.new(runner.resultant)
    cleared = true
  rescue
    ##
    # puts "   Failed to get the testable page."
    _log("*  Failed to get the testable page: #{$!}")
  end
  
  if cleared

    ## Walk through tests.
    runner.tests.each do |t|
      _log("   Trying test: #{t.to_s}")
      result = $vpage.send t
      # puts "\t\t" + result.to_s
    end
    
    ## Walk through assertions.
    runner.assertions.each do |a|
      # puts "a: #{a}"
      # puts "a.class: #{a.class}"
      # puts "a[0]: #{a[0]}"
      # puts "a[1]: #{a[1]}"
      # puts "a[2]: #{a[2]}"
      lval_key = a.fetch('sub', nil)
      op = a.fetch('op', nil)
      rval = a.fetch('arg', nil)
      _log( "   Trying assertion: #{lval_key.to_s} #{op.to_s} #{rval.to_s}")
      # puts "\t\t" + $vpage.assert(a).to_s
    end
    
    ## Output: files and logging.
    $vpage.dump($output, runner.id)
    
    $vpage.warnings.each do |w|
      _log("#{runner.id}: warning: #{w}")
    end
    
    $vpage.errors.each do |e|
      _log("#{runner.id}: ERROR: #{e}")
      $errors = $errors + 1
    end

    ## Check to see if there are any continues.
    runner.continue.each do |next_desc|
      _log("   Do a continue <==")
      next_pagent = runner.resultant
      next_runner = PageRunner.new(next_pagent, next_desc)
      inspector(next_runner)
    end
    
  else
    ## 
  end
  
end

###
### Program body.
###

## Ready up.
_erase_log $log_file
_ready_dir $output
_clear_output_dir $output

test_files = File.join("**", "*.t")
Dir.glob(test_files).sort.each do |test_desc|
  
  $runner = PageRunner.new($url, test_desc)
  inspector($runner)
      
end

##
puts "Finished with #{$errors} errors."
_log("Finished with #{$errors} errors.")
