#!/usr/bin/ruby1.8 -w
####
#### TODO: Still needs to be run from geneontology/go-dev/amigo/testing.
#### TODO: Agents should share cookies...
#### TODO: Randomized input (generate new test files on the fly?).
####
#### irb (TODO: does this still work?):
####    ['pagent.rb', 'amigo.rb', 'aunit.rb', 'kappa'].each{|l| load l }
####
#### example command line (mostly for cron):
####    GEM_HOME=/home/sjcarbon/local/ruby RUBYOPT=rubygems RUBYLIB=/home/sjcarbon/local/ruby/lib:/home/sjcarbon/local/src/svn/geneontology/go-dev/amigo/testing /home/sjcarbon/local/src/svn/geneontology/go-dev/amigo/testing/kappa --url http://amigo.berkeleybop.org/cgi-bin/amigo --output /local/www/htdocs/amigo/kappa --tests /home/sjcarbon/local/src/svn/geneontology/go-dev/amigo/testing/profiles/amigo
####
#### NOTE: Right now, data is determined by absolute paths.
####

require 'getoptlong'
# require 'rdoc/usage'

require 'pagent'
require 'amigo'
require 'aunit'
require 'json/pure'
#require 'amb'
#require 'nondeterminism'

include AmiGO
include AUnit

###
### Collect options.
###

##
opts = GetoptLong.new(
                      ['--help', '-h', GetoptLong::NO_ARGUMENT],
                      ## NOTE: Right now, data is determined by absolute paths.
                      # ['--data', '-d', GetoptLong::REQUIRED_ARGUMENT],
                      ['--tests', '-t', GetoptLong::REQUIRED_ARGUMENT],
                      ['--output', '-o', GetoptLong::REQUIRED_ARGUMENT],
                      ['--url', '-u', GetoptLong::REQUIRED_ARGUMENT]
                      )

## Defaults--some probably not very sensible.
# data = './data'
tests = './profiles/tests' # ? should this be switched on if __FILE__ == $0
output = '/tmp'
url = 'http://localhost'

## Arg loop.
opts.each do |opt, arg|
  case opt
  when '--help'
    ## TODO: 
    # RDoc::usage
    #inspector.log("Please see the source code for now for usage and examples.")
    puts("Please see the source code for now for usage and examples.")
    Kernel.exit
  when '--url'
    url = arg
    puts("* Will use base URL: \"#{url}\".")
  when '--tests'
    tests = arg
    puts("* Will look for tests in: \"#{tests}\".")
  # when '--data'
  #   data = arg
  #   puts("* Will look for test data in: \"#{tests}\".")
  when '--output'
    output = arg
    puts("* Will output test information to: \"#{output}\".")
  end
end

## Make sure that dir things are directories.
# [data, tests, output].each do |d|
[output].each do |d|
  if not File.writable? d
    raise "directory argument not writable: #{d}"
  end
end

###
### Program body.
###

##
inspector = Inspector.new(output)

## Clean up if we already ran this.
inspector.erase_logs
inspector.ready_dir
inspector.clear_output_dir

## Ready up.

##
logging_hash = Hash.new()
errors = 0

##
Dir.chdir(tests) # TODO: definitely a better way of doing this...
test_files = File.join("**", "*.t")
Dir.glob(test_files).sort.each do |test_desc|

  inspector.log("Found test: #{test_desc}")
  inspector.log("Found test: #{test_desc}", :file)

  ## Runner contains all profile info.
  $runner = PageRunner.new(url, test_desc)
  # prof = $runner.profile

  ## Inspector returns all logging/testing warnings and errors.
  # probs = inspector.collect $runner
  inspector.inspect $runner

  ## TODO: Most of this in here can be folded into Inspector
  ## Merge them into a dumpable super object.
  res_hash = Hash.new()
  res_hash['warnings'] = inspector.warnings
  res_hash['errors'] = inspector.errors
  res_hash['id'] = inspector.profile_id
  res_hash['comment'] = inspector.profile_comment
  res_hash['reference'] = inspector.profile_reference
  res_hash['generated_files'] = inspector.generated_files

  ##
  logging_hash[inspector.profile_id] = res_hash
  errors = errors + res_hash['errors'].size   
end

##
inspector.log("Finished with #{errors} error(s).")
inspector.log("Finished with #{errors} error(s).", :file)
inspector.write_struct logging_hash

###
### TODO: randomly generate input.
###

# $test_map[:random] = proc do

#   ## Get initial page for probing.
#   $t9 = PAgent::HTML.new($te_home_url)

#   ## Create a speciesdb subset using amb.
#   all_sdb = $t9.select_values('term_enrichment_form', 'speciesdb')
#   $sbd_subset = []
#   amb = Amb.new
#   begin
#     a = amb.choose(all_asdb)
#     @a.assert(  )
#         @a.assert( a + b == c )
#         assert( (a < b) && (a + b == c) )
#         solutions.push({:a => a, :b => b, :c => c})
#         @a.search
#       rescue Amb::ExhaustedError
#         #inspector.log("No More Solutions")
#       end

# ## Get large bank of GPs.
# $gp_bank = [];
# ['gp/All_genes',
#  'gp/sc_product_list',
#  'gp/total-genes-MGIMGI.txt'].each do |fname|

#   full_name = $data_home + fname
#   file = File.new(full_name)
#   file.each do |line|
#     $gp_bank.push(line.chomp)
#   end
#   file.close

# end

# ## Shuffle banked gene products...
# shuffled = $gp_bank.sort_by { rand }
# $gp_subset = shuffled.slice(0,100)
# $bggp_subset = shuffled.slice(0,500)

# ## Create form template.
# $random_form_hash = {
#   'form' => 'term_enrichment_form',
#   'multi_select' => {'speciesdb' => ['SGD', 'dictyBase', 'MGI']},
#   'radio' => {'iea' => 'yes'},
#   'field' => {
#     #'request' => 'results',
#     #'force' => 'yes',
#     'cutoff' => '10',
#     'gp_list' => $gp_subset.join(' '),
#     'bggp_list' => $bggp_subset.join(' ')
#   }
# }

# ## Run page.
# $t9.form_from_conf(Conf.new($random_form_hash))
# $t10 = $t9.submit('term_enrichment')

#   ## May have timed out.
#   if ! $t10.nil?

#     ## Run out the visualization from the TE results pages if
#     ## possible.
#     $t11 = $t10.submit('visualize')
#     if ! $t11.nil?
#       inspector.log("got image: " + $t11.dump($output))
#     else
#       inspector.log("random visualize may have timed out")
#     end
#   else
#     inspector.log("random TE may have timed out")
#   end

# end
