/*
 * Copyright 2006 Google Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package org.bbop.server;


import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.bbop.client.RefGenomeService;
import org.bbop.client.model.DateDTO;
import org.bbop.client.model.GeneOrGeneProductNodeDTO;
import org.bbop.client.model.NodeDTO;
import org.bbop.client.model.StatementDTO;
import org.bbop.dataadapter.DataAdapterException;
import org.bbop.server.parser.RefGenomeTargetHomologsParser;
import org.obd.model.Graph;
import org.obd.model.LinkStatement;
import org.obd.model.LiteralStatement;
import org.obd.model.Node;
import org.obd.model.Statement;
import org.obd.query.BooleanQueryTerm;
import org.obd.query.ComparisonQueryTerm;
import org.obd.query.LabelQueryTerm;
import org.obd.query.LinkQueryTerm;
import org.obd.query.QueryTerm;
import org.obd.query.Shard;
import org.obd.query.BooleanQueryTerm.BooleanOperator;
import org.obd.query.LabelQueryTerm.AliasType;
import org.obd.query.QueryTerm.Aspect;
import org.obd.query.impl.MultiShard;
import org.obd.query.impl.MutableOBOSessionShard;
import org.obd.query.impl.OBDSQLShard;
import org.obd.query.impl.OBOSessionShard;

import com.google.gwt.user.server.rpc.RemoteServiceServlet;

/**
 * The implemenation of the RPC service which runs on the server.
 */
public class RefGenomeServiceImpl extends RemoteServiceServlet implements RefGenomeService {

	/**
	 * Autogenerated fun.
	 */
	private static final long serialVersionUID = 1L;

	private Map<String,NodeDTO> nodeCache = new HashMap<String,NodeDTO>();

	//static String userName = "sjcarbon";
	//static String password = "";
	static String userName = "remote_user";
	static String password = "glurp";

	//static String defaultJdbcPath = "jdbc:postgresql://spitz.lbl.gov:5432/obd_refg";
	static String defaultJdbcPath = "jdbc:postgresql://localhost:5432/obd_refg";

	private String jdbcPath = null;
	
	private String currentUserId;
	private DateDTO currentDate;


	private Shard shard = null;
	private Shard speciesInfoShard = null;

	public RefGenomeServiceImpl() {
		super();
		setup();
	}

	public RefGenomeServiceImpl(String jdbcPath) {
		super();
		setJdbcPath(jdbcPath);
		setup();
	}

	public String getJdbcPath() {
		return jdbcPath == null ? defaultJdbcPath : jdbcPath;
	}

	public void setJdbcPath(String jdbcPath) {
		this.jdbcPath = jdbcPath;
	}

	// TODO: make configurable
	public void setup() {
		if (shard != null)
			return;
		shard = new MultiShard();
		System.err.println("shard="+shard);
		try {		
			OBDSQLShard obd;
			obd = new OBDSQLShard();
			System.err.println("connecting="+shard);
			obd.connect(getJdbcPath(), userName, password);
			System.err.println("obd="+obd);
			((MultiShard)shard).addShard(obd);
		} catch (SQLException e) {
			e.printStackTrace();
			System.exit(1);
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		speciesInfoShard = new MutableOBOSessionShard();
		try {
			((MutableOBOSessionShard)speciesInfoShard).loadFile(refGenomeSpeciesPath);
		} catch (DataAdapterException e) {
			// TODO : backup plan?
			e.printStackTrace();
		}
		System.err.println("//shard="+shard);

		// Use this in case of mystery errors.
		//		// Optional: Crank up the logging.
		if (true) {
			Handler[] handlers = Logger.getLogger( "" ).getHandlers();

			for ( int index = 0; index < handlers.length; index++ ) {
				handlers[index].setLevel( Level.FINE );
			}
			Logger l1 = Logger.getLogger("org.bbop.rdbms");
			Logger l2 = Logger.getLogger("org.obd");
			Logger l3 = Logger.getLogger("org.obd..shard.OBDSQLShard");
			l1.setLevel(Level.FINEST);
			l2.setLevel(Level.FINEST);
			l3.setLevel(Level.FINEST);
		}
	}

	public NodeDTO fetchNodeByIdCached(String id) {
		if (nodeCache.containsKey(id))
			return nodeCache.get(id);
		NodeDTO dto = fetchNodeById(id);
		nodeCache.put(id, dto);
		return dto;
	}
	public NodeDTO fetchNodeById(String id) {
		try {
			//NodeDTO[] nodeDTOs;
			Node n = shard.getNode(id);
			NodeDTO nDTO = slurpNodeInfo(n);
			return nDTO;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	//
	public NodeDTO[] fetchNodesByName(String searchTerm) {

		Collection<Node> nodes;

		try {
			//NodeDTO[] nodeDTOs;
			nodes = shard.getNodesBySearch(searchTerm, 
					ComparisonQueryTerm.Operator.STARTS_WITH); // TODO
			return slurpNodesInfo(nodes);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null; // TODO
	}

	private NodeDTO slurpNodeInfo(Node n) {
		if (n == null)
			return null;
		// attach metadata to node
		LinkQueryTerm qt = new LinkQueryTerm(n.getId(),null,null);
		qt.setInferred(false);
		Collection<Statement> stmts = shard.getStatementsByQuery(qt);
		System.err.println("adding statements for "+n+" :: "+stmts.size());
		n.addStatements(stmts);
		NodeDTO taxon = null;
		for (Statement s : stmts) {
			if (s.getRelationId().equals(IN_ORGANISM)) {
				taxon = this.fetchNodeByIdCached(s.getTargetId());
				System.err.println("TAXON="+taxon);
			}
		}

		System.err.println("n="+n);
		/*
		NodeDTO nDTO = new NodeDTO(n.getId());
		nDTO.setLabel(n.getLabel());
		nDTO.setSourceId(n.getSourceId());
		 */
		NodeDTO nDTO = nodeToDTO(n);
		if (taxon != null)
			nDTO.setInOrganismType(taxon);
		//nodeDTOs.add(nDTO);

		return nDTO;
	}
	
	private NodeDTO[] slurpNodesInfo(Collection<Node> nodes) {
		//Collection<NodeDTO> nodeDTOs = new LinkedList<NodeDTO>();
		//System.err.println("nodes size = "+ nodes.size() + "");
		NodeDTO[] nodeDTOs = new NodeDTO[nodes.size()];
		int i = 0;
		for (Node n : nodes) {
			NodeDTO nDTO = slurpNodeInfo(n);
			nodeDTOs[i] = nDTO;
			i++;
		}
		return nodeDTOs;
	
	}
	

	public GeneOrGeneProductNodeDTO[] fetchGeneOrGeneProductNodesByName(String searchTerm) {
		NodeDTO[] nodes = fetchNodesByName(searchTerm);
		GeneOrGeneProductNodeDTO[] gps = new GeneOrGeneProductNodeDTO[nodes.length];
		// TODO
		return gps;
	}


	public String[] fetchIdsByNameAndTaxon(String searchTerm, String taxonId) {
		// TODO Auto-generated method stub
		return null;
	}
	
	public NodeDTO[] fetchNodesByNameAndTaxon(String searchTerm, String taxonId) {
		Collection<Node> nodes;

		try {
			BooleanQueryTerm bqt = new BooleanQueryTerm(BooleanOperator.AND);
			bqt.addQueryTerm(new LinkQueryTerm(IN_ORGANISM,taxonId));
			bqt.addQueryTerm(new LabelQueryTerm(AliasType.ANY_LABEL,searchTerm));
			//NodeDTO[] nodeDTOs;
			nodes = shard.getNodesByQuery(bqt);
			return slurpNodesInfo(nodes);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}

	// NOTE: This works fine.
	public String[] fetchReferenceTaxonIds() {
		return nodesToIds(speciesInfoShard.getNodes());
	}
	public NodeDTO[] fetchReferenceTaxonNodes() {
		return nodesToDTOs(speciesInfoShard.getNodes());
	}

	public NodeDTO fetchTaxonNodeForEntity(String id) {
		Collection<Node> taxons = shard.getNodesByQuery(new LinkQueryTerm(id,"OBO_REL:in_organism",null));
		Iterator<Node> it = taxons.iterator();
		if (it.hasNext())
			return nodeToDTO(it.next());
		return null;

	}



	public String[] fetchEntityIdsInHomologSet(String homologSetId) {
		// TODO Auto-generated method stub
		return null;
	}

	//public Map<String, String> fetchLabelMapsById(String searchTerm) {
	public Map fetchLabelMapsById(String searchTerm) {
		// TODO Auto-generated method stub
		return null;
	}

	public String[] fetchLabelsById(String searchTerm) {
		// TODO Auto-generated method stub
		return null;
	}

	public String[] fetchReferenceTargetIds() {
		String rel = HAS_STATUS;
		String ob = STATUS_TARGET;
		Collection<Node> nodes = shard.getNodesByQuery(new LinkQueryTerm(rel,ob));
		return this.nodesToIds(nodes);
	}

	public NodeDTO[] fetchReferenceTargetNodes() {
		String rel = HAS_STATUS;
		String ob = STATUS_TARGET;
		Collection<Node> nodes = shard.getNodesByQuery(new LinkQueryTerm(rel,ob));
		return slurpNodesInfo(nodes);
	}

	public NodeDTO[] fetchReferenceTargetNodesByName(String name) {
		BooleanQueryTerm bqt = new BooleanQueryTerm(BooleanOperator.AND);
		String rel = HAS_STATUS;
		String ob = STATUS_TARGET;
		LinkQueryTerm lqt = new LinkQueryTerm(rel,ob);
		bqt.addQueryTerm(lqt);
		bqt.addQueryTerm(new LabelQueryTerm(AliasType.ANY_LABEL, name));
		Collection<Node> nodes = shard.getNodesByQuery(bqt);
		return slurpNodesInfo(nodes);
	}
	/*
	public String[] fetchReferenceTargetIds() {
		// TODO Auto-generated method stub
		String[] sa =  new String[0];

		String ob = "";
		String rel = "";
		String su = "";
		Collection<Statement> stmts = shard.getStatements(su , rel, ob, null, null, null);
		for (Statement s : stmts) {
			s.setRelationId(HAS_EX_STATUS);
		}
		Graph g = new Graph(stmts);
		shard.putGraph(g);


		return sa;
	}
	 */

	public String getTaxonIdPrefix() {
		// TODO Auto-generated method stub
		return null;
	}

	public void addUser(String userId, String fullName, String password) {
		// TODO Auto-generated method stub

	}


	//@Deprecated
	//public void retractGeneTargetStatus(String userId, String geneId) {
	//	retractStatement(geneId,HAS_STATUS,STATUS_TARGET,userId,currentDate);	
	//}


	public void assignEntityComprehensivelyAnnotatedStatus(String userId, String geneId, DateDTO date) {
		addStatement(geneId,HAS_STATUS,STATUS_COMPREHENSIVELY_ANNOTATED,userId,date);	
	}

	public void assignEntityStatusCode(String userId, String statusId, String geneId, DateDTO date) {
		addStatement(geneId,HAS_STATUS,statusId,userId,date);	
	}

	public void assignEntityTargetStatus(String userId, String geneId, DateDTO date) {
		System.err.println("assigning target status to "+geneId);
		addStatement(geneId,HAS_STATUS,STATUS_TARGET,userId,date);	
	}


	public void assignHomologyLinkStatement(String userId, String nodeId, String targetId, String[] methodIds, String provenanceId, String comment) {
		Graph g = new Graph();
		Statement s = makeHomologyStatement(userId,nodeId,targetId,methodIds,provenanceId,comment);
		g.addStatement(s);
		shard.putGraph(g);
	}

	public void assignNegativeHomologyLinkStatement(String userId, String e1id, String e2id, String[] methodIds, String provenanceId, String comment) {
		Graph g = new Graph();
		Statement s = makeHomologyStatement(userId,e1id,e2id,methodIds,provenanceId,comment);
		s.setNegated(true);
		g.addStatement(s);
		shard.putGraph(g);

	}

	public void attachCommentToEntity(String entityId, String comment, String curatorId) {
		// TODO Auto-generated method stub

	}

	public Boolean checkUserPassword(String userId, String password) {
		// TODO Auto-generated method stub
		boolean logstatus = true;
		return new Boolean(logstatus);

	}

	public String[] fetchHomologousEntityIds(String entityId) {
		// TODO Auto-generated method stub
		return null;
	}

	public StatementDTO[] fetchHomologyLinkStatementsByEntityId(String entityId) {
		// TODO Auto-generated method stub
		return null;
	}



	public NodeDTO[] getAllUsers() {
		// TODO Auto-generated method stub
		return null;
	}

	public NodeDTO[] getHomologyMethodTypeNodes() {
		// TODO Auto-generated method stub
		return null;
	}

	public NodeDTO[] getStatusCodeNodes() {
		// TODO Auto-generated method stub
		return null;
	}

	public void retractEntityComprehensivelyAnnotatedStatus(String userId, String geneId) {
		// TODO Auto-generated method stub

	}

	public void retractEntityStatusCode(String userId, String statusId, String geneId) {
		// TODO Auto-generated method stub

	}

	public void retractEntityTargetStatus(String userId, String geneId) {
		// TODO Auto-generated method stub

	}

	public void uploadFile(String userId, String filePath, String fileType) {
		if (filePath == null)
			filePath = RefGenomeTargetHomologsParser.getDefaultURL();
		if (filePath.startsWith("ftp:") || filePath.startsWith("http:")) {
			try {
				Runtime.getRuntime().exec("wget -O /tmp/refg.txt "+filePath);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return; // TODO - fail
			}
			filePath = "/tmp/refg.txt"; // TODO - use URLs

		}
		RefGenomeTargetHomologsParser parser = new RefGenomeTargetHomologsParser(filePath);
		RefGenomeService rgs = this;
		parser.setRefgService(rgs);
		parser.setUserId(userId);

		DateDTO date = new DateDTO(2008,4,16); // TODO
		parser.setDate(date);

		try {
			parser.parse();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

	private void addStatement(String su, String rel, String ob, String userId, DateDTO date) {
		LinkStatement s = new LinkStatement(su,rel,ob,userId);
		if (date == null) {
			System.err.println("no date!");
		}
		else 
			s.addSubLiteralStatement(ON_DATE, date.toString());
		Graph g = new Graph();
		g.addStatement(s);
		shard.putGraph(g);
	}

	private void retractStatement(String su, String rel, String ob, String userId, DateDTO date) {
		Collection<Statement> stmts = shard.getStatements(su, rel, ob, null, null, null);
		for (Statement s : stmts) {
			s.setRelationId(HAS_EX_STATUS);
		}
		Graph g = new Graph(stmts);
		shard.putGraph(g);
	}

	public boolean isSetComprehensivelyAnnotated(String entityId) {
		// TODO Auto-generated method stub
		return false;
	}

	private Statement makeHomologyStatement(String userId, String e1id, String e2id, String[] methodIds, String provenanceId, String comment) {
		LinkStatement s = new LinkStatement(e1id,HOMOLOGOUS_TO,e2id,userId);
		if (currentDate != null)
			s.addSubLiteralStatement(ON_DATE, currentDate.toString());
		s.addSubLiteralStatement(HAS_PROVENANCE, provenanceId);
		for (String methodId : methodIds)
			s.addSubLiteralStatement(HAS_EVIDENCE, methodId);
		if (comment != null)
			s.addSubLiteralStatement(HAS_COMMENT, comment);
		return s;
	}

	private String[] nodesToIds(Collection<Node> nodes) {
		String[] nids = new String[nodes.size()];
		Iterator<Node> it = nodes.iterator();
		for (int i=0; it.hasNext(); i++) {
			nids[i] = it.next().getId();
		}
		return nids;
	}
	private NodeDTO[] nodesToDTOs(Collection<Node> nodes) {
		NodeDTO[] dtos = new NodeDTO[nodes.size()];
		Iterator<Node> it = nodes.iterator();
		for (int i=0; it.hasNext(); i++) {
			dtos[i] = nodeToDTO(it.next());
		}
		return dtos;
	}


	private NodeDTO nodeToDTO(Node node) {
		NodeDTO dto = new NodeDTO(node.getId());
		dto.setLabel(node.getLabel());
		dto.setSourceId(node.getSourceId());
		if (node.getStatements().length > 0) {
			dto.setStatements(statementsToDTOs(node.getStatements()));
		}
		// TODO - statements
		return dto;
	}

	private StatementDTO statementToDTO(Statement s) {
		StatementDTO dto = new StatementDTO(s.getNodeId(),s.getRelationId(),null);
		if (s instanceof LiteralStatement) {
			dto.setTargetId(((LiteralStatement)s).getSValue());
		}
		else {
			dto.setTargetId(s.getTargetId());
		}
		return dto;

	}

	private StatementDTO[] statementsToDTOs(Collection<Statement> stmts) {
		StatementDTO[] dtos = new StatementDTO[stmts.size()];
		Iterator<Statement> it = stmts.iterator();
		for (int i=0; it.hasNext(); i++) {
			dtos[i] = statementToDTO(it.next());
		}
		return dtos;
	}

	private StatementDTO[] statementsToDTOs(Statement[] stmts) {
		Collection<Statement> al = java.util.Arrays.asList(stmts);
		return statementsToDTOs(al);
	}

}
