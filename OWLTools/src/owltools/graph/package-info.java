/**
* <h2>OWLGraph -- Graph Wrapper for OWL Ontologies<h2>
 * 
 * <h3>Formalism</h3>
 * An OWLOntology includes a set of named objects O, 
 * a set of class expressions X and a set of axioms A.
 * <p>
 * An OWLGraph is a graph consisting of nodes N, edges E and edge labels L
 * <p>
 * Each edge in E is a triple consisting of a source, a target and an edge
 * label. Unlike RDF, a label is a complex structure, and consists of a
 * distance value and one or more quantified relations. A quantified relation is
 * a subclass relation or a tuple <Property Quantifier>.
 * <p>
 * <code>
 * E = 'Edge(' SourceNode QR* Distance Target ')'
 * </code>
* <p>
 * <code>
 * QR = some Property | all Property | Cardinality(Min,Max) Property | SUBCLASS_OF | INSTANCE_OF
 * </code>
 * <p>
 * N consists of the union of O and X. N can be subdivided into named named objects and expressions,
 * No and Nx. 
 * <p>
 * <h3>Construction of OWLGraph from OWLOntology</h3>
 * First primitive edges are seeded:
 * <p>
 * <h4>OWL Axioms</h4>
 * <p>
 * The following rules produce edges from the set of axioms A
 * <ul>
 * <li>
 * <code>
 * SubClassOf(x y) ==> Edge(x,subclass,y)
 * </code>
 * <li>
 * <code>
 * EquivalentClasses(x y) ==> Edge(x,subclass,y)
 * </code>
 * </ul>
 * <p>
 * <h4>OWL Expressions</h4>
 * <p>
 * The following rules produces edges from the set of class expressions referenced:
 * <ul>
 * <li>
 * <code>
 * ObjectSomeValuesFrom(p x) ==> Edge( ObjectSomeValuesFrom(p x), p*some, x)
 * </code>
 * <li>
 * <code>
 * ObjectOnlyValuesFrom(p x) ==> Edge(ObjectOnlyValuesFrom(p x),  p*only, x)
 * </code>
 * <li>
 * <code>
 * IntersectionOf(x1 x2 ... xn) ==> Edge( IntersectionOf(x1 x2 ... xn), subclass, x1), ..., Edge( IntersectionOf(x1 x2 ... xn), subclass, xn)
 * </code>
 * </ul>
 * named node edges are generated by finding all minimal paths between all named
 * nodes. QRs are concatenated, but subclass edges are eliminated.
 * <p>
 * EXAMPLE
 * <code>
 * SubClassOf(foo ObjectSomeValuesFrom(r a)) ==> 
 * EdgeP(foo, SUBCLASS_OF,ObjectSomeValuesFrom(r a)), EdgeP(objectSomeValuesFrom(r a),r some, a) ==>
 * EdgeN(foo,r some,a)
 * </code>
 * <p>
 * EXAMPLE
 * <p>
 * <code>
 * foo EquivalentTo (a and (r some (s some b))) ==>
 *   Edge(foo,subclass,a)
 *   Edge(foo,&lt;r some>&lt;s some>,b) 
 * </code>  
 * <p>
 * <h3>Graph Closure</h3>
 * The graph closure can be calculated using a <i>composition table</i> that collapses
 * sequences of QRs together:
 * <p>
 * <pre>
 * <code>
 * sub * sub --> sub
 * sub * R some --> R some
 * R some> * sub --> R some
 * sub * R only --> R only
 * R only * sub --> R only
 * R some * R some --> R some 
 *    <i>on condition:</i> TransitiveProperty(r)
 * R1 some * R2 some * ... * Rn some --> R some
 *      <i>on condition:</i>  SubPropertyOf( PropertyChain(R1 .. Rn) R)
 * </code>
 * </pre>
 *  <p>
 *  if the combination is not found then the QRs are concatenated
 *  <p>
 *     
 * 
 * @see <a href="http://wiki.geneontology.org/index.php/OWLTools">OWLTools</a> for more context
 */
package owltools.graph;

import owltools.graph.OWLGraphWrapper;
import owltools.gfx.OWLGraphLayoutRenderer;
