package owltools.graph;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.Vector;

import org.semanticweb.owlapi.apibinding.OWLManager;
import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLAnnotation;
import org.semanticweb.owlapi.model.OWLAnnotationProperty;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLClassAssertionAxiom;
import org.semanticweb.owlapi.model.OWLClassExpression;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLEntity;
import org.semanticweb.owlapi.model.OWLEquivalentClassesAxiom;
import org.semanticweb.owlapi.model.OWLIndividual;
import org.semanticweb.owlapi.model.OWLLiteral;
import org.semanticweb.owlapi.model.OWLNamedIndividual;
import org.semanticweb.owlapi.model.OWLNamedObject;
import org.semanticweb.owlapi.model.OWLObject;
import org.semanticweb.owlapi.model.OWLObjectAllValuesFrom;
import org.semanticweb.owlapi.model.OWLObjectHasValue;
import org.semanticweb.owlapi.model.OWLObjectIntersectionOf;
import org.semanticweb.owlapi.model.OWLObjectPropertyAssertionAxiom;
import org.semanticweb.owlapi.model.OWLObjectPropertyExpression;
import org.semanticweb.owlapi.model.OWLObjectSomeValuesFrom;
import org.semanticweb.owlapi.model.OWLObjectUnionOf;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.model.OWLRestriction;
import org.semanticweb.owlapi.model.OWLSubClassOfAxiom;
import org.semanticweb.owlapi.vocab.OWLRDFVocabulary;

import owltools.graph.OWLQuantifiedProperty.Quantifier;

/**
 * Provides simple graph-like operations over the OWLAPI. In addition, provides
 * additional convenience wrapping to OWLAPI e.g. for annotation properties.
 * (these capabilities may in future be split).
 * 
 * 
 * == OWLGraph formalism ==
 * 
 * An OWLOntology includes a set of named objects O, 
 * a set of class expressions X and a set of axioms A.
 * 
 * An OWLGraph is a graph consisting of nodes N, edges E and edge labels L
 * 
 * Each edge in E is a triple consisting of a source, a target and an edge
 * label. Unlike RDF, a label is a complex structure, and consists of a
 * distance value and one or more quantified relations. A quantified relation is
 * a subclass relation or a tuple <Property Quantifier>.
 * Quantifier = SOME | ALL | CARDINALITY(Min,Max)
 * 
 * N consists of O and X. N can be subdivided into named named objects and expressions,
 * No and Nx. 
 * 
 * First primitive edges are seeded:
 * 
 * OWL Axioms:
 * 
 * x SubClassOf y ==> Edge(x,subclass,y)
 * x EquivalentTo y ==> Edge(x,subclass,y)
 * 
 * OWL Expressions:
 * 
 * {p some x} ==> Edge({p some x}, <p some> x)
 * {p only x} ==> Edge({p only x}, <p only> x)
 * {x1 and x2 ... xn} ==> Edge({...}, subclass, x1), ..., Edge({...}, subclass, xn)
 * 
 * named node edges are generated by finding all minimal paths between all named
 * nodes. QRs are concatenated, but subclass edges are eliminated.
 * 
 * EXAMPLE
 * foo SubClassOf r some a ==> 
 * EdgeP(foo,sub,{r some a}),EdgeP({r some a},<r some>,a) ==>
 * EdgeN(foo,<r some>,a)
 * 
 * 
 * EXAMPLE
 * foo EquivalentTo (a and (r some (s some b))) ==>
 *   Edge(foo,subclass,a)
 *   Edge(foo,<r some><s some>,b) 
 *   
 * The graph closure can be calculated using a composition table that collapses
 * sequences of QRs together:
 * 
 * sub * sub --> sub
 * sub * <r some> --> <r some>
 * <r some> * sub --> <r some>
 * sub * <r all> --> <r all>
 * <r all> * sub --> <r all>
 * <r some> * <r some> --> <r some> condition: TransitiveProperty(r)
 * <r1 some> * <r2 some> * ... * <rn some> --> 
 *     <r some> condition: SubPropertyOf( PropertyChain(r1 .. rn) r)
 *     
 *  TODO: options for including closure with complementation
 *  
 *  if the combination is not found then the QRs are concatenated
 *     
 *  TODO: delegate closure code to a separate class   
 *  
 * @see OWLGraphUtil
 * @author cjm
 *
 */
public class OWLGraphWrapper {

	public static final String DEFAULT_IRI_PREFIX = "http://purl.obolibrary.org/obo/";
	
	
	OWLOntology ontology;
	OWLDataFactory dataFactory;
	OWLOntologyManager manager;
	Config config = new Config();
	
	private Map<OWLObject,Set<OWLGraphEdge>> edgeBySource;
	private Map<OWLObject,Set<OWLGraphEdge>> edgeByTarget;
	private Map<OWLObject,Set<OWLGraphEdge>> inferredEdgeBySource = null;
	private Map<OWLObject,Set<OWLGraphEdge>> inferredEdgeByTarget = null;

	// used to store mappings child->parent, where
	// parent = UnionOf( ..., child, ...)
	private Map<OWLObject,Set<OWLObject>> extraSubClassOfEdges = null;

	
	/**
	 * Configuration options. These are typically specific to a
	 * OWLGraphWrapper instance.
	 *
	 */
	public class Config {
		// by default the graph closure includes only named entities
		public boolean isIncludeClassExpressionsInClosure = false;

		// by default we do not follow complement of - TODO
		public boolean isFollowComplementOfInClosure = false;

		public boolean isCacheClosure = true;

	}

	/**
	 * Create a new wrapper for an OWLOntology
	 */
	public OWLGraphWrapper(OWLOntology ontology) {
		super();
		OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
		dataFactory = manager.getOWLDataFactory();
		this.ontology = ontology;
	}



	public OWLOntology getOntology() {
		return ontology;
	}



	public void setOntology(OWLOntology ontology) {
		this.ontology = ontology;
	}

	// ----------------------------------------
	// BASIC GRAPH EDGE TRAVERSAL
	// ----------------------------------------

	/**
	 * retrieves direct edges from a source
	 * to the direct **named** target
	 * 
	 * e.g. if (A SubClassOf B) then outgoing(A) = { <A,sub,B>}
	 * e.g. if (A SubClassOf R some B) then outgoing(A) = { <A, R-some, B> }
	 * e.g. if (A SubClassOf R some (R2 some B)) then outgoing(A) = { <A, [R-some,R2-same], B> }
	 * 
	 * @param source
	 * @return all edges that originate from source to nearest named object target
	 */
	public Set<OWLGraphEdge> getOutgoingEdges(OWLObject cls) {
		Set<OWLGraphEdge> pEdges = getPrimitiveOutgoingEdges(cls);
		Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
		for (OWLGraphEdge e : pEdges) {
			edges.addAll(primitiveEdgeToFullEdges(e));
		}
		return edges;
	}
	
	private Set<OWLObject> getOutgoingEdgesViaReverseUnion(OWLObject child) {
		if (extraSubClassOfEdges == null)
			cacheReverseUnionMap();
		if (extraSubClassOfEdges.containsKey(child)) 
			return extraSubClassOfEdges.get(child);
		else
			return new HashSet<OWLObject>();
	}
	
	private void cacheReverseUnionMap() {
		extraSubClassOfEdges = new HashMap<OWLObject, Set<OWLObject>>();
		for (OWLClass cls : ontology.getClassesInSignature()) {
			for (OWLEquivalentClassesAxiom eca : ontology.getEquivalentClassesAxioms(cls)) {
				for (OWLClassExpression ce : eca.getClassExpressions()) {
					if (ce instanceof OWLObjectUnionOf) {
						for (OWLObject child : ((OWLObjectUnionOf)ce).getOperands()) {
							if (extraSubClassOfEdges.containsKey(child)) {
								extraSubClassOfEdges.get(child).add(cls);
							}
							else {
								extraSubClassOfEdges.put(child, new HashSet<OWLObject>());
								extraSubClassOfEdges.get(child).add(cls);
							}
						}
					}
				}
			}
		}
	}

	/**
	 * primitive edges connect any combination of named objects and expressions
	 * 
	 * e.g. (A SubClassOf R some B) => <A,sub,R-some-B>, <R-some-B,R-some,B>
	 * @param source
	 * @return
	 */
	public Set<OWLGraphEdge> getPrimitiveOutgoingEdges(OWLObject s) {
		Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
		if (s instanceof OWLClass) {
			
			for (OWLSubClassOfAxiom sca : ontology.getSubClassAxiomsForSubClass((OWLClass) s)) {
				edges.add(createSubClassOfEdge(sca.getSubClass(), sca.getSuperClass()));
			}
			for (OWLEquivalentClassesAxiom eqa : ontology.getEquivalentClassesAxioms((OWLClass) s)) {
				for (OWLClassExpression ce : eqa.getClassExpressions()) {
					if (!ce.equals(s))
						edges.add(createSubClassOfEdge(s, ce));
				}
			}
			for (OWLObject pbu : getOutgoingEdgesViaReverseUnion(s)) {
				if (pbu instanceof OWLClass)
					edges.add(createSubClassOfEdge(s,(OWLClass)pbu));
			}
	
		}
		else if (s instanceof OWLIndividual) {
			// TODO - do we care about punning?
			// need to define semantics here
			for (OWLClassAssertionAxiom a : ontology.getClassAssertionAxioms((OWLIndividual) s)) {
				edges.add(new OWLGraphEdge(s,a.getClassExpression(),null,Quantifier.INSTANCE_OF,ontology));
			}
			for (OWLObjectPropertyAssertionAxiom a : ontology.getObjectPropertyAssertionAxioms((OWLIndividual) s)) {
				edges.add(new OWLGraphEdge(s,a.getObject(),a.getProperty(),Quantifier.PROPERTY_ASSERTION,ontology));
			}
		}
		else if (s instanceof OWLRestriction<?>) {
			edges.add(restrictionToPrimitiveEdge((OWLRestriction<?>) s));
		}
		else if (s instanceof OWLObjectIntersectionOf) {
			for (OWLClassExpression ce : ((OWLObjectIntersectionOf)s).getOperands()) {
				edges.add(createSubClassOfEdge(s,ce));
			}
		}
		else if (s instanceof OWLObjectUnionOf) {
			// do nothing in this direction
		}
		return edges;
	}


	// e.g. R-some-B ==> <R-some-B,R,B>
	private OWLGraphEdge restrictionToPrimitiveEdge(OWLRestriction s) {
		OWLObjectPropertyExpression p = null;
		OWLObject t = null;
		OWLQuantifiedProperty.Quantifier q = null;
		if (s instanceof OWLObjectSomeValuesFrom) {
			t  = ((OWLObjectSomeValuesFrom)s).getFiller();
			p = (OWLObjectPropertyExpression) s.getProperty();
			q = OWLQuantifiedProperty.Quantifier.SOME;
		}
		else if (s instanceof OWLObjectAllValuesFrom) {
			t  = ((OWLObjectAllValuesFrom)s).getFiller();
			p = (OWLObjectPropertyExpression) s.getProperty();
			q = OWLQuantifiedProperty.Quantifier.ONLY;
		}
		else if (s instanceof OWLObjectHasValue) {
			t  = ((OWLObjectHasValue)s).getValue();
			p = (OWLObjectPropertyExpression) s.getProperty();
			q = OWLQuantifiedProperty.Quantifier.VALUE;
		}
		else {
			System.err.println("cannot handle:"+s);
		}
		return new OWLGraphEdge(s,t,p,q,ontology);
	}

	private OWLGraphEdge createSubClassOfEdge(OWLObject s, OWLClassExpression t) {
		return new OWLGraphEdge(s,t,null,Quantifier.SUBCLASS_OF,ontology);
	}


	// extend an edge target until we hit a named object.
	// this could involve multiple extensions and "forks", e.g.
	// <A sub B^C> ==> <A sub B>, <A sub C>
	private Set<OWLGraphEdge> primitiveEdgeToFullEdges(OWLGraphEdge e) {
		Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
		if (e.isTargetNamedObject()) {
			edges.add(e); // do nothing
		}
		else {
			// extend
			OWLObject s = e.getSource();
			edges = getOutgoingEdges(e.getTarget());
			for (OWLGraphEdge e2 : edges) {
				e2.setSource(s);
			}
		}
		return edges;
	}



	/**
	 * in general you should not need to call this
	 */
	public void cacheEdges() {
		edgeBySource = new HashMap<OWLObject,Set<OWLGraphEdge>>();
		edgeByTarget = new HashMap<OWLObject,Set<OWLGraphEdge>>();

		for (OWLObject s : getAllOWLObjects()) {
			if (!edgeBySource.containsKey(s))
				edgeBySource.put(s, new HashSet<OWLGraphEdge>());
			for (OWLGraphEdge edge : getOutgoingEdges(s)) {
				edgeBySource.get(s).add(edge);
				OWLObject t = edge.getTarget();
				if (!edgeByTarget.containsKey(t))
					edgeByTarget.put(t, new HashSet<OWLGraphEdge>());
				edgeByTarget.get(t).add(edge);
			}
		}
	}

	public  Set<OWLGraphEdge> getIncomingEdges(OWLObject t) {
		ensureEdgesCached();
		return edgeByTarget.get(t);
	}


	private void ensureEdgesCached() {
		if (edgeByTarget == null)
			cacheEdges();

	}




	/**
	 * pack/translate an edge (either asserted or a graph closure edge) into
	 * an OWL class expression according to the OWLGraph to OWLOntology
	 * translation rules.
	 * 
	 * (this is the reverse translation of the one from an OWLOntology to an
	 * OWLGraph)
	 * 
	 * e.g. after calling for the graph closure of an OWLClass a,
	 * we may get back an edge <a [part_of-some, adjacent_to-some, has_part-some] b>.
	 * after feeding this edge into this method we obtain the expression
	 *   part_of some (adjacent_to some (has_part some b))
	 * 
	 * @param edge
	 * @return class expression equivalent to edge
	 */
	public OWLObject edgeToTargetExpression(OWLGraphEdge e) {
		return edgeToTargetExpression(e.getQuantifiedPropertyList().iterator(),e.getTarget());
	}
	private OWLObject edgeToTargetExpression(
			Iterator<OWLQuantifiedProperty> qpi, OWLObject t) {
		if (qpi.hasNext()) {
			OWLQuantifiedProperty qp = qpi.next();
			OWLObject t2 = edgeToTargetExpression(qpi,t);
			if (qp.isSubClassOf()) {
				return t2;
			}
			else if (qp.isSomeValuesFrom()) {
				return dataFactory.getOWLObjectSomeValuesFrom(qp.getProperty(), 
						(OWLClassExpression) t2);
			}
			else if (qp.isAllValuesFrom()) {
				return dataFactory.getOWLObjectAllValuesFrom(qp.getProperty(), 
						(OWLClassExpression) t2);
			}
			else {
				System.err.println("cannot handle:"+qp);
				// TODO
				return null;
			}
		}
		else {
			return t;
		}
	}


	// ----------------------------------------
	// GRAPH CLOSURE METHODS
	// ----------------------------------------

	
	/**
	 * Retrieves the graph closure originating from source.
	 * E.g. if A SubClassOf R some B & B SubClassOf S some C, then
	 * closure(A) = { <A R-some B>, <A [R-some,S-some] C>.
	 * 
	 * Composition rules are used to compact the list of connecting edge labels
	 * (e.g. transitivity).
	 * 
	 * The resulting edges can be translated into class expressions using 
	 * method edgeToTargetExpression(e). E.g. in the above the expression would be
	 *   R some (S some C)
	 * 
	 * @param source
	 * @return closure of edges originating from source
	 */
	public Set<OWLGraphEdge> getOutgoingEdgesClosure(OWLObject s) {
		
		if (config.isCacheClosure) {
			if (inferredEdgeBySource == null)
				inferredEdgeBySource = new HashMap<OWLObject,Set<OWLGraphEdge>>();
			if (inferredEdgeBySource.containsKey(s)) {
				return inferredEdgeBySource.get(s);
			}
		}
		Stack<OWLGraphEdge> edgeStack = new Stack<OWLGraphEdge>();
		Set<OWLGraphEdge> closureSet = new HashSet<OWLGraphEdge>();
		Set<OWLGraphEdge> visitedSet = new HashSet<OWLGraphEdge>();
		Set<OWLObject> visitedObjs = new HashSet<OWLObject>();
		
		// initialize. we seed the search with a reflexive identity edge DEPR
		//edgeStack.add(new OWLGraphEdge(s,s,null,Quantifier.IDENTITY,ontology));
		
		// seed stack
		edgeStack.addAll(getPrimitiveOutgoingEdges(s));
		closureSet.addAll(edgeStack);
		while (!edgeStack.isEmpty()) {
			OWLGraphEdge ne = edgeStack.pop();
			//System.out.println("NEXT: "+ne+" //stack: "+edgeStack);
			int nextDist = ne.getDistance() + 1;
			Set<OWLGraphEdge> extSet = getPrimitiveOutgoingEdges(ne.getTarget());
			for (OWLGraphEdge extEdge : extSet) {
				//System.out.println("   EXT:"+extEdge);
				OWLGraphEdge nu = combineEdgePair(s, ne, extEdge, nextDist);
				OWLObject nuTarget = nu.getTarget();
				//System.out.println("     COMBINED:"+nu);
				
				// check for cycles. this is not as simple as
				// checking if we have visited the node, as we are interested
				// in different paths to the same node
				//if (!visitedSet.contains(nu)) {
				boolean isEdgeVisited = false;
				if (visitedObjs.contains(nuTarget)) {
					// we have potentially visited this edge before
					
					
					// TODO - this is temporary. need to check edge not node
					isEdgeVisited = true;
					/*
					System.out.println("checking to see if  visisted "+nu);
					System.out.println(nu.getFinalQuantifiedProperty());
					for (OWLGraphEdge ve : visitedSet) {
						System.out.println(" ve:"+ve.getFinalQuantifiedProperty());
						if (ve.getFinalQuantifiedProperty().equals(nu.getFinalQuantifiedProperty())) {
							System.out.println("already visisted: "+nu);
							isEdgeVisited = true;
						}
					}
					*/
				}
				else {
					visitedObjs.add(nuTarget);
				}
				
				if (!isEdgeVisited) {
					//System.out.println("      *NOT VISITED:"+nu+" visistedSize:"+visitedSet.size());
					if (nu.getTarget() instanceof OWLNamedObject || 
							config.isIncludeClassExpressionsInClosure) {
						closureSet.add(nu);
					}
					edgeStack.add(nu);
					visitedSet.add(nu);		
					
				}
			}
		}
		
		if (config.isCacheClosure) {
			inferredEdgeBySource.put(s, closureSet);
		}
		return closureSet;
	}
	
	/**
	 * find the set of classes or class expressions subsuming source, using the graph closure.
	 * 
	 * this is just the composition of getOutgoingEdgesClosure and edgeToTargetExpression -- the
	 * latter method "packs" a chain of edges into a class expression
	 * 
	 * only "linear" expressions are found, corresponding to a path in the graph.
	 * e.g. [sub,part_of-some,develops_from-some] ==> part_of some (develops_from some t)
	 * 
	 * if the edge consists entirely of subclass links, the the subsumers will be all
	 * named classes.
	 * 
	 * @param source
	 * @return
	 */
	public Set<OWLObject> getSubsumersFromClosure(OWLObject s) {
		Set<OWLObject> ts = new HashSet<OWLObject>();
		for (OWLGraphEdge e : getOutgoingEdgesClosure(s)) {
			ts.add(edgeToTargetExpression(e));
		}
		return ts;
	}
	
	/**
	 * @param source
	 * @param target
	 * @return all edges connecting source and target in the graph closure
	 */
	public Set<OWLGraphEdge> getEdgesBetween(OWLObject s, OWLObject t) {
		
		// some duplication with the above method...
		Stack<OWLGraphEdge> edgeStack = new Stack<OWLGraphEdge>();
		Set<OWLGraphEdge> closureSet = new HashSet<OWLGraphEdge>();
		Set<OWLGraphEdge> visitedSet = new HashSet<OWLGraphEdge>();
		
		// initialize
		//edgeStack.add(new OWLGraphEdge(s,s,ontology,new OWLQuantifiedProperty()));
		edgeStack.addAll(getPrimitiveOutgoingEdges(s));
		
		while (!edgeStack.isEmpty()) {
			OWLGraphEdge ne = edgeStack.pop();
			int nextDist = ne.getDistance() + 1;
			Set<OWLGraphEdge> extSet = getPrimitiveOutgoingEdges(ne.getTarget());
			for (OWLGraphEdge extEdge : extSet) {
				OWLGraphEdge nu = combineEdgePair(s, ne, extEdge, nextDist);
				if (!visitedSet.contains(nu)) {
					// note this is different from the previous method
					// -- only add to closure set if this edge connects s and t
					if (nu.getTarget().equals(t)) {
						closureSet.add(nu);
					}
					else {
						// we only want to go beyond here if we have NOT
						// found the target
						edgeStack.add(nu);
					}
					visitedSet.add(nu);		
				}
			}
		}
		return closureSet;
	}

	
	/**
	 * returns all ancestors of an object. Here, ancestors is defined as any
	 * named object that can be reached from x over some path of asserted edges.
	 * relations are ignored.
	 * 
	 * @param source
	 * @return all reachable target nodes, regardless of edges
	 */
	public Set<OWLObject> getAncestors(OWLObject x) {
		Set<OWLObject> ancs = new HashSet<OWLObject>();
		for (OWLGraphEdge e : getOutgoingEdgesClosure(x)) {
			ancs.add(e.getTarget());
		}
		return ancs;
	}
	public Set<OWLObject> getAncestorsReflexive(OWLObject x) {
		Set<OWLObject> ancs = getAncestors(x);
		ancs.add(x);
		return ancs;
	}
		
	/**
	 * TODO
	 * @see getOutgoingEdgesClosure
	 * @param target
	 * @return all edges connecting all descendents of target to target
	 */
	public Set<OWLGraphEdge> getIncomingEdgesClosure(OWLObject t) {
		
		Stack<OWLGraphEdge> edgeStack = new Stack<OWLGraphEdge>();
		Set<OWLGraphEdge> closureSet = new HashSet<OWLGraphEdge>();
		Set<OWLGraphEdge> visitedSet = new HashSet<OWLGraphEdge>();
		
		// initialize
		//edgeStack.add(new OWLGraphEdge(t,t,ontology,new OWLQuantifiedProperty()));
		edgeStack.addAll(getIncomingEdges(t));
		
		while (!edgeStack.isEmpty()) {
			OWLGraphEdge ne = edgeStack.pop();
			int nextDist = ne.getDistance() + 1;
			Set<OWLGraphEdge> extSet = getIncomingEdges(ne.getSource());
			for (OWLGraphEdge extEdge : extSet) {
				OWLGraphEdge nu = combineEdgePairDown(ne, t, extEdge, nextDist);
				if (!visitedSet.contains(nu)) {
					closureSet.add(nu);
					edgeStack.add(nu);
					visitedSet.add(nu);		
				}
			}
		}
		return closureSet;
	}


	/**
	 * combine ne and extEdge to create a new edge.
	 * 
	 * @param s
	 * @param ne
	 * @param extEdge
	 * @param nextDist
	 * @return
	 */
	private OWLGraphEdge combineEdgePair(OWLObject s, OWLGraphEdge ne, OWLGraphEdge extEdge, int nextDist) {
		//System.out.println("combing edges: "+ne+ " * "+extEdge);
		// Create an edge with no edge labels; we will fill the label in later
		OWLGraphEdge nu = new OWLGraphEdge(s, extEdge.getTarget());
		nu.setDistance(nextDist);
		Vector<OWLQuantifiedProperty> qps = new Vector<OWLQuantifiedProperty>();
		
		// TODO - PropertyChains - need to match the tail of the list of QRs

		// put all but the final one in a new list
		int n = 0;
		int size = ne.getQuantifiedPropertyList().size();
		OWLQuantifiedProperty finalQP = null;
		for (OWLQuantifiedProperty qp : ne.getQuantifiedPropertyList()) {
			n++;
			if (n < size)
				qps.add(qp);
			else
				finalQP = qp;
		}
		OWLQuantifiedProperty combinedQP = 
			combinedQuantifiedPropertyPair(ne.getFinalQuantifiedProperty(), extEdge.getSingleQuantifiedProperty());
		if (combinedQP == null) {
			qps.add(finalQP);
			qps.add(extEdge.getSingleQuantifiedProperty());
		}
		else {
			qps.add(combinedQP);
		}
		nu.setQuantifiedPropertyList(qps);
		//System.out.println("DONE edges: "+ne+ " * "+extEdge+" ==> "+nu);

		return nu;
	}

	private OWLGraphEdge combineEdgePairDown(OWLGraphEdge ne, OWLObject t, OWLGraphEdge extEdge, int nextDist) {
		// fill in edge label later
		OWLGraphEdge nu = new OWLGraphEdge(extEdge.getSource(), t);
		nu.setDistance(nextDist);
		Vector<OWLQuantifiedProperty> qps = new Vector<OWLQuantifiedProperty>();

		// put all but the final one in a new list
		int n = 0;
		int size = ne.getQuantifiedPropertyList().size();
		OWLQuantifiedProperty finalQP = null;
		for (OWLQuantifiedProperty qp : ne.getQuantifiedPropertyList()) {
			n++;
			if (n > 1)
				qps.add(qp);
			else
				finalQP = qp;
		}
		// TODO
		OWLQuantifiedProperty combinedQP = 
			combinedQuantifiedPropertyPair(ne.getFinalQuantifiedProperty(), extEdge.getSingleQuantifiedProperty());
		if (combinedQP == null) {
			qps.add(finalQP);
			qps.add(extEdge.getSingleQuantifiedProperty());
		}
		else {
			qps.add(combinedQP);
		}
		nu.setQuantifiedPropertyList(qps);
		return nu;
	}

	/**
	 * Edge composition rules
	 */
	private OWLQuantifiedProperty combinedQuantifiedPropertyPair(OWLQuantifiedProperty x, OWLQuantifiedProperty y) {
		//System.out.println("combing "+x+"+"+y);
		if (x.isSubClassOf() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(Quantifier.SUBCLASS_OF);
		}
		else if (x.isInstanceOf() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(Quantifier.INSTANCE_OF);
		}
		else if (x.isSubClassOf() && y.isSomeValuesFrom()) {
			return new OWLQuantifiedProperty(y.getProperty(),Quantifier.SOME);
		}
		else if (x.isSomeValuesFrom() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(x.getProperty(),Quantifier.SOME);
		}
		else if (x.isSomeValuesFrom() &&
				y.isSomeValuesFrom() &&
				x.getProperty() != null && 
				x.getProperty().equals(y.getProperty()) && 
				x.getProperty().isTransitive(ontology)) {
			return new OWLQuantifiedProperty(x.getProperty(),Quantifier.SOME);
		}
		else if (x.isPropertyAssertion() &&
				y.isPropertyAssertion() &&
				x.getProperty() != null && 
				x.getProperty().equals(y.getProperty()) && 
				x.getProperty().isTransitive(ontology)) {
			return new OWLQuantifiedProperty(x.getProperty(),Quantifier.PROPERTY_ASSERTION);
		}
		else if (x.isSubClassOf() && y.isAllValuesFrom()) {
			return new OWLQuantifiedProperty(y.getProperty(),Quantifier.ONLY);
		}
		else if (x.isAllValuesFrom() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(x.getProperty(),Quantifier.ONLY);
		}
		else {
			// cannot combine - caller will add QP to sequence
			return null;
		}
	}


	/**
	 * Find all edges of the form <i INST c> in the graph closure.
	 * (this includes both direct assertions, plus assertions to objects
	 *  that link to c via a chain of SubClassOf assertions)
	 *  
	 *  the semantics are the same as inferred ClassAssertion axioms
	 * 
	 * @param owlClass
	 * @return all individuals classified here via basic graph traversal
	 */
	public Set<OWLIndividual> getInstancesFromClosure(OWLClass c) {
		Set<OWLIndividual> ins = new HashSet<OWLIndividual>();
		// iterate through all individuals; sequential scan may be slow for
		// large knowledge bases
		for (OWLIndividual in : ontology.getIndividualsInSignature()) {
			for (OWLGraphEdge e : getEdgesBetween(in, c)) {
				List<OWLQuantifiedProperty> qps = e.getQuantifiedPropertyList();
				// check for edges of the form < i INSTANCE_OF c >
				// we exclude relation chaims, e.g. <i [INSTANCE_OF PART_OF-some] c>
				if (qps.size() == 1 && qps.get(0).isInstanceOf()) {
					ins.add(in);
					break;
				}
			}
		}
		return ins;
	}
	
	/**
	 * Finds all edges between an instance i and he given class c.
	 * 
	 * this includes inferred class assertions, as well as chains such as
	 * 
	 * i has_part j, j inst_of k, k part_of some c
	 * 
	 * @param owlClass
	 * @return all edges in closure between an instance and owlClass
	 */
	public Set<OWLGraphEdge> getInstanceChainsFromClosure(OWLClass c) {
		Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
		// iterate through all individuals; sequential scan may be slow for
		// large knowledge bases
		for (OWLIndividual in : ontology.getIndividualsInSignature()) {
			edges.addAll(getEdgesBetween(in, c));
		}
		return edges;
	}

	
	// ----------------------------------------
	// BASIC WRAPPER UTILITIES
	// ----------------------------------------
	
	/**
	 * @return all named objects
	 */
	public Set<OWLObject> getAllOWLObjects() {
		Set<OWLClass> cls = ontology.getClassesInSignature();
		Set<OWLNamedIndividual> ins = ontology.getIndividualsInSignature();
		Set<OWLObject> obs = new HashSet<OWLObject>();
		obs.addAll(cls);
		obs.addAll(ins);
		return obs;
	}
	
	
	/**
	 * assumes zero or one rdfs:label
	 * 
	 * @param c
	 * @return
	 */
	public String getLabel(OWLObject c) {
		OWLAnnotationProperty lap = dataFactory.getOWLAnnotationProperty(OWLRDFVocabulary.RDFS_LABEL.getIRI()); 
		Set<OWLAnnotation>anns = null;
		if (c instanceof OWLEntity) {
			anns = ((OWLEntity) c).getAnnotations(ontology,lap);
		}
		else {
			return null;
		}
		for (OWLAnnotation a : anns) {
			if (a.getValue() instanceof OWLLiteral) {
				OWLLiteral val = (OWLLiteral) a.getValue();
				return val.getLiteral(); // return first - todo - check zero or one
			}
		}
		return null;
	}

	
	/**
	 * assumes zero or one def
	 * It returns the definition text (encoded as def in obo format and IAO_0000115 annotation property in OWL format) of a class
	 * @param c
	 * @return
	 */
	public String getDef(OWLObject c) {
		OWLAnnotationProperty lap = dataFactory.getOWLAnnotationProperty(IRI.create(DEFAULT_IRI_PREFIX + "IAO_0000115")); 
		Set<OWLAnnotation>anns = null;
		if (c instanceof OWLEntity) {
			anns = ((OWLEntity) c).getAnnotations(ontology,lap);
		}
		else {
			return null;
		}
		for (OWLAnnotation a : anns) {
			if (a.getValue() instanceof OWLLiteral) {
				OWLLiteral val = (OWLLiteral) a.getValue();
				return val.getLiteral(); // return first - todo - check zero or one
			}
		}
		return null;
	}
	
	/**
	 * Return the names of the asserted subClasses of the cls (Class) 
	 * passed in the argument
	 * @param cls
	 * @return
	 */
	public String[] getSubClassesNames(OWLClass cls){
		Set<OWLClassExpression> st = cls.getSubClasses(ontology);
		

		ArrayList<String> ar = new ArrayList<String>();
		for(OWLClassExpression ce: st){
			if(ce instanceof OWLNamedObject)
				ar.add(getLabel(ce)); 
		}

		return ar.toArray(new String[ar.size()]);
	}

	/**
	 * It returns array of synonyms (is encoded as synonym in obo format and IAO_0000118 annotation property in OWL format) of a class
	 * @param c
	 * @return
	 */
	public String[] getSynonymStrings(OWLObject c) {
		OWLAnnotationProperty lap = dataFactory.getOWLAnnotationProperty(IRI.create(DEFAULT_IRI_PREFIX + "IAO_0000118")); 
		Set<OWLAnnotation>anns = null;
		if (c instanceof OWLEntity) {
			anns = ((OWLEntity) c).getAnnotations(ontology,lap);
		}
		else {
			return null;
		}
		
		ArrayList<String> list = new ArrayList<String>();
		for (OWLAnnotation a : anns) {
			if (a.getValue() instanceof OWLLiteral) {
				OWLLiteral val = (OWLLiteral) a.getValue();
				list.add(val.getLiteral()); // return first - todo - check zero or one
			}
		}
		return list.toArray(new String[list.size()]);
	}
	
	
	public String getIdentifier(OWLObject owlObject) {
		if (owlObject instanceof OWLNamedObject) {
			String iri = ((OWLNamedObject)owlObject).getIRI().toString();
			if (iri.startsWith("http://purl.obolibrary.org/obo/")) {
				iri = iri.replace("http://purl.obolibrary.org/obo/", "");
				int p = iri.lastIndexOf('_');
				if (p >= 0) {
					iri = iri.substring(0, p) + ":" + iri.substring(p+1);
				}
			}
			
			return iri;

		}
		return "";
	}




	public IRI getIRIByIdentifier(String id) {
		String[] parts = id.split(":", 2);
		String s;
		if (parts.length <2) {
			// TODO!
			s = "http://purl.obolibrary.org/obo/TODO_"+parts[0];
		}
		else {
			s = "http://purl.obolibrary.org/obo/"+parts[0]+"_"+parts[1];
		}
		
		return IRI.create(s);
	}

	/**
	 * translates to obo URIs
	 * 
	 * @param id - e.g. GO:0008150
	 * @return
	 */
	public OWLObject getOWLObjectByIdentifier(String id) {
		return dataFactory.getOWLClass(getIRIByIdentifier(id));
	}

	public OWLObject getOWLObjectPropertyByIdentifier(String id) {
		return dataFactory.getOWLObjectProperty(getIRIByIdentifier(id));
	}

	
	/**
	 * @param iri
	 * @return
	 */
	public OWLObject getOWLClass(String s) {
		IRI iri = IRI.create(s);
		OWLClass c = dataFactory.getOWLClass(iri);
		if (ontology.getDeclarationAxioms(c).size() == 0) {
			return null;
		}
		return c;
	}
	
	public OWLObject getOWLClass(OWLObject x) {
		return dataFactory.getOWLClass(((OWLNamedObject)x).getIRI());
	}


	public OWLObject getOWLIndividual(String s) {
		IRI iri = IRI.create(s);
		OWLNamedIndividual c = dataFactory.getOWLNamedIndividual(iri);
		if (ontology.getDeclarationAxioms(c).size() == 0) {
			return null;
		}
		return c;
	}


	public OWLObject getOWLObject(String s) {
		OWLObject o;
		o = getOWLClass(s);
		if (o == null) {
			o = getOWLIndividual(s);
		}
		return o;
	}







	

}
