package owltools.graph;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.Vector;

import org.semanticweb.owlapi.apibinding.OWLManager;
import org.semanticweb.owlapi.model.IRI;
import org.semanticweb.owlapi.model.OWLAnnotation;
import org.semanticweb.owlapi.model.OWLAnnotationProperty;
import org.semanticweb.owlapi.model.OWLAxiom;
import org.semanticweb.owlapi.model.OWLClass;
import org.semanticweb.owlapi.model.OWLClassExpression;
import org.semanticweb.owlapi.model.OWLDataFactory;
import org.semanticweb.owlapi.model.OWLEquivalentClassesAxiom;
import org.semanticweb.owlapi.model.OWLIndividual;
import org.semanticweb.owlapi.model.OWLLiteral;
import org.semanticweb.owlapi.model.OWLNamedIndividual;
import org.semanticweb.owlapi.model.OWLNamedObject;
import org.semanticweb.owlapi.model.OWLObject;
import org.semanticweb.owlapi.model.OWLObjectIntersectionOf;
import org.semanticweb.owlapi.model.OWLObjectPropertyExpression;
import org.semanticweb.owlapi.model.OWLObjectSomeValuesFrom;
import org.semanticweb.owlapi.model.OWLObjectUnionOf;
import org.semanticweb.owlapi.model.OWLOntology;
import org.semanticweb.owlapi.model.OWLOntologyManager;
import org.semanticweb.owlapi.model.OWLRestriction;
import org.semanticweb.owlapi.model.OWLSubClassOfAxiom;
import org.semanticweb.owlapi.vocab.OWLRDFVocabulary;

import owltools.graph.OWLQuantifiedProperty.Quantifier;

/**
 * Provides simple graph-like operations over the OWLAPI.
 * 
 * An OWLOntology includes a set of named objects O, 
 * a set of class expressions X and a set of axioms A.
 * 
 * An OWLGraph is a graph consisting of nodes N, edges E and edge labels L
 * 
 * Each edge in E is a triple consisting of a source, a target and an edge
 * label. Unlike RDF, a label is a complex structure, and consists of a
 * distance value and one or more quantified relations. A quantified relation is
 * a subclass relation or a tuple <Property Quantifier>.
 * Quantifier = SOME | ALL | CARDINALITY(Min,Max)
 * 
 * N consists of O and X. N can be subdivided into named named objects and expressions,
 * No and Nx. 
 * 
 * First primitive edges are seeded:
 * 
 * OWL Axioms:
 * 
 * x SubClassOf y ==> Edge(x,subclass,y)
 * x EquivalentTo y ==> Edge(x,subclass,y)
 * 
 * OWL Expressions:
 * 
 * {p some x} ==> Edge({p some x}, <p some> x)
 * {p only x} ==> Edge({p only x}, <p only> x)
 * {x1 and x2 ... xn} ==> Edge({...}, subclass, x1), ..., Edge({...}, subclass, xn)
 * 
 * named node edges are generated by finding all minimal paths between all named
 * nodes. QRs are concatenated, but subclass edges are eliminated.
 * 
 * EXAMPLE
 * foo SubClassOf r some a ==> 
 * EdgeP(foo,sub,{r some a}),EdgeP({r some a},<r some>,a) ==>
 * EdgeN(foo,<r some>,a)
 * 
 * 
 * EXAMPLE
 * foo EquivalentTo (a and (r some (s some b))) ==>
 *   Edge(foo,subclass,a)
 *   Edge(foo,<r some><s some>,b) 
 *   
 * The graph closure can be calculated using a composition table that collapses
 * sequences of QRs together:
 * 
 * sub * sub --> sub
 * sub * <r some> --> <r some>
 * <r some> * sub --> <r some>
 * sub * <r all> --> <r all>
 * <r all> * sub --> <r all>
 * <r some> * <r some> --> <r some> condition: TransitiveProperty(r)
 * <r1 some> * <r2 some> * ... * <rn some> --> 
 *     <r some> condition: SubPropertyOf( PropertyChain(r1 .. rn) r)
 *     
 *  TODO: options for including closure with complementation
 *  
 *  if the combination is not found then the QRs are concatenated
 *     
 *  TODO: delegate closure code to a separate class   
 *  
 * @see OWLGraphUtil
 * @author cjm
 *
 */
public class OWLGraphWrapper {

	OWLOntology ontology;
	OWLDataFactory dataFactory;
	OWLOntologyManager manager;
	Config config = new Config();
	private Map<OWLObject,Set<OWLGraphEdge>> edgeBySource;
	private Map<OWLObject,Set<OWLGraphEdge>> edgeByTarget;
	
	public class Config {
		// by default the graph closure includes only named entities
		public boolean isIncludeClassExpressionsInClosure = false;

		// by default we do not follow complement of - TODO
		public boolean isFollowComplementOfInClosure = false;

	}

	public OWLGraphWrapper(OWLOntology ontology) {
		super();
		OWLOntologyManager manager = OWLManager.createOWLOntologyManager();
		dataFactory = manager.getOWLDataFactory();
		this.ontology = ontology;
	}



	public OWLOntology getOntology() {
		return ontology;
	}



	public void setOntology(OWLOntology ontology) {
		this.ontology = ontology;
	}



	/**
	 * this method is for retrieving edges between _named_ objects
	 * 
	 * e.g. (A SubClassOf R some B) => <A, R-some, B>
	 * @param source
	 * @return all edges that originate from source
	 */
	public  Set<OWLGraphEdge> getOutgoingEdges(OWLObject cls) {
		Set<OWLGraphEdge> pEdges = getPrimitiveOutgoingEdges(cls);
		Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
		for (OWLGraphEdge e : pEdges) {
			edges.addAll(primitiveEdgeToFullEdges(e));
		}
		return edges;
	}

	private Set<OWLGraphEdge> primitiveEdgeToFullEdges(OWLGraphEdge e) {
		Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
		if (e.isTargetNamedObject()) {
			edges.add(e); // do nothing
		}
		else {
			// extend
			OWLObject s = e.getSource();
			edges = getOutgoingEdges(e.getTarget());
			for (OWLGraphEdge e2 : edges) {
				e2.setSource(s);
			}
		}
		return edges;
	}
	
	/**
	 * @param s
	 * @return
	 */
	public Set<OWLGraphEdge> getOutgoingEdgesClosure(OWLObject s) {
		
		Stack<OWLGraphEdge> edgeStack = new Stack<OWLGraphEdge>();
		Set<OWLGraphEdge> closureSet = new HashSet<OWLGraphEdge>();
		Set<OWLGraphEdge> visitedSet = new HashSet<OWLGraphEdge>();
		
		// initialize
		edgeStack.add(new OWLGraphEdge(s,s,ontology,new OWLQuantifiedProperty()));
		
		while (!edgeStack.isEmpty()) {
			OWLGraphEdge ne = edgeStack.pop();
			//System.out.println("NEXT: "+ne+" //stack: "+edgeStack);
			int nextDist = ne.getDistance() + 1;
			Set<OWLGraphEdge> extSet = getPrimitiveOutgoingEdges(ne.getTarget());
			for (OWLGraphEdge extEdge : extSet) {
				//System.out.println("   EXT:"+extEdge);
				OWLGraphEdge nu = combineEdgePair(s, ne, extEdge, nextDist);
				//System.out.println("     COMBINED:"+nu);
				if (!visitedSet.contains(nu)) {
					//System.out.println("      *NOT VISITED:"+nu+" visistedSize:"+visitedSet.size());
					if (nu.getTarget() instanceof OWLNamedObject || 
							config.isIncludeClassExpressionsInClosure) {
						closureSet.add(nu);
					}
					edgeStack.add(nu);
					visitedSet.add(nu);		
				}
			}
		}
		return closureSet;
	}
	
	public Set<OWLGraphEdge> getEdgesBetween(OWLObject s, OWLObject t) {
		
		// some duplication with the above method...
		Stack<OWLGraphEdge> edgeStack = new Stack<OWLGraphEdge>();
		Set<OWLGraphEdge> closureSet = new HashSet<OWLGraphEdge>();
		Set<OWLGraphEdge> visitedSet = new HashSet<OWLGraphEdge>();
		
		// initialize
		edgeStack.add(new OWLGraphEdge(s,s,ontology,new OWLQuantifiedProperty()));
		
		while (!edgeStack.isEmpty()) {
			OWLGraphEdge ne = edgeStack.pop();
			int nextDist = ne.getDistance() + 1;
			Set<OWLGraphEdge> extSet = getPrimitiveOutgoingEdges(ne.getTarget());
			for (OWLGraphEdge extEdge : extSet) {
				OWLGraphEdge nu = combineEdgePair(s, ne, extEdge, nextDist);
				if (!visitedSet.contains(nu)) {
					// note this is different from the previous method
					// -- only add to closure set if this edge connects s and t
					if (nu.getTarget().equals(t)) {
						closureSet.add(nu);
					}
					else {
						// we only want to go beyond here if we have NOT
						// found the target
						edgeStack.add(nu);
					}
					visitedSet.add(nu);		
				}
			}
		}
		return closureSet;
	}

	
	/**
	 * returns all ancestors of an object. Here, ancestors is defined as any
	 * named object that can be reached from x over some path of asserted edges.
	 * relations are ignored.
	 */
	public Set<OWLObject> getAnctesors(OWLObject x) {
		Set<OWLObject> ancs = new HashSet<OWLObject>();
		for (OWLGraphEdge e : getOutgoingEdgesClosure(x)) {
			ancs.add(e.getTarget());
		}
		return ancs;
	}

	public Set<OWLGraphEdge> getIncomingEdgesClosure(OWLObject t) {
		
		Stack<OWLGraphEdge> edgeStack = new Stack<OWLGraphEdge>();
		Set<OWLGraphEdge> closureSet = new HashSet<OWLGraphEdge>();
		Set<OWLGraphEdge> visitedSet = new HashSet<OWLGraphEdge>();
		
		// initialize
		edgeStack.add(new OWLGraphEdge(t,t,ontology,new OWLQuantifiedProperty()));
		
		while (!edgeStack.isEmpty()) {
			OWLGraphEdge ne = edgeStack.pop();
			int nextDist = ne.getDistance() + 1;
			Set<OWLGraphEdge> extSet = getIncomingEdges(ne.getSource());
			for (OWLGraphEdge extEdge : extSet) {
				OWLGraphEdge nu = combineEdgePairDown(ne, t, extEdge, nextDist);
				if (!visitedSet.contains(nu)) {
					closureSet.add(nu);
					edgeStack.add(nu);
					visitedSet.add(nu);		
				}
			}
		}
		return closureSet;
	}


	/**
	 * combine ne and extEdge to create a new edge
	 * 
	 * @param s
	 * @param ne
	 * @param extEdge
	 * @param nextDist
	 * @return
	 */
	private OWLGraphEdge combineEdgePair(OWLObject s, OWLGraphEdge ne, OWLGraphEdge extEdge, int nextDist) {
		OWLGraphEdge nu = new OWLGraphEdge(s, extEdge.getTarget());
		nu.setDistance(nextDist);
		Vector<OWLQuantifiedProperty> qps = new Vector<OWLQuantifiedProperty>();

		// put all but the final one in a new list
		int n = 0;
		int size = ne.getQuantifiedPropertyList().size();
		OWLQuantifiedProperty finalQP = null;
		for (OWLQuantifiedProperty qp : ne.getQuantifiedPropertyList()) {
			n++;
			if (n < size)
				qps.add(qp);
			else
				finalQP = qp;
		}
		OWLQuantifiedProperty combinedQP = 
			combinedQuantifiedPropertyPair(ne.getFinalQuantifiedProperty(), extEdge.getSingleQuantifiedProperty());
		if (combinedQP == null) {
			qps.add(finalQP);
			qps.add(extEdge.getSingleQuantifiedProperty());
		}
		else {
			qps.add(combinedQP);
		}
		nu.setQuantifiedPropertyList(qps);
		return nu;
	}

	private OWLGraphEdge combineEdgePairDown(OWLGraphEdge ne, OWLObject t, OWLGraphEdge extEdge, int nextDist) {
		OWLGraphEdge nu = new OWLGraphEdge(extEdge.getSource(), t);
		nu.setDistance(nextDist);
		Vector<OWLQuantifiedProperty> qps = new Vector<OWLQuantifiedProperty>();

		// put all but the final one in a new list
		int n = 0;
		int size = ne.getQuantifiedPropertyList().size();
		OWLQuantifiedProperty finalQP = null;
		for (OWLQuantifiedProperty qp : ne.getQuantifiedPropertyList()) {
			n++;
			if (n > 1)
				qps.add(qp);
			else
				finalQP = qp;
		}
		// TODO
		OWLQuantifiedProperty combinedQP = 
			combinedQuantifiedPropertyPair(ne.getFinalQuantifiedProperty(), extEdge.getSingleQuantifiedProperty());
		if (combinedQP == null) {
			qps.add(finalQP);
			qps.add(extEdge.getSingleQuantifiedProperty());
		}
		else {
			qps.add(combinedQP);
		}
		nu.setQuantifiedPropertyList(qps);
		return nu;
	}

	private OWLQuantifiedProperty combinedQuantifiedPropertyPair(OWLQuantifiedProperty x, OWLQuantifiedProperty y) {
		if (x.isSubClassOf() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(Quantifier.SUBCLASS_OF);
		}
		if (x.isInstanceOf() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(Quantifier.INSTANCE_OF);
		}
		else if (x.isSubClassOf() && y.isSomeValuesFrom()) {
			return new OWLQuantifiedProperty(y.getProperty(),Quantifier.SOME);
		}
		else if (x.isSomeValuesFrom() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(x.getProperty(),Quantifier.SOME);
		}
		else if (x.getProperty().equals(y.getProperty()) && 
				x.getProperty().isTransitive(ontology)) {
			return new OWLQuantifiedProperty(x.getProperty(),Quantifier.SOME);
		}
		else if (x.isSubClassOf() && y.isAllValuesFrom()) {
			return new OWLQuantifiedProperty(y.getProperty(),Quantifier.ONLY);
		}
		else if (x.isAllValuesFrom() && y.isSubClassOf()) {
			return new OWLQuantifiedProperty(x.getProperty(),Quantifier.ONLY);
		}
		else {
			// TODO - extend
			return null;
		}
	}


	/**
	 * e.g. (A SubClassOf R some B) => <A,sub,R-some-B>, <R-some-B,R-some,B>
	 * @param source
	 * @return
	 */
	public  Set<OWLGraphEdge> getPrimitiveOutgoingEdges(OWLObject s) {
		Set<OWLGraphEdge> edges = new HashSet<OWLGraphEdge>();
		if (s instanceof OWLClass) {
			
			for (OWLSubClassOfAxiom sca : ontology.getSubClassAxiomsForSubClass((OWLClass) s)) {
				edges.add(expressionToPrimitiveEdge(sca.getSubClass(), sca.getSuperClass()));
			}
			for (OWLEquivalentClassesAxiom eqa : ontology.getEquivalentClassesAxioms((OWLClass) s)) {
				for (OWLClassExpression ce : eqa.getClassExpressions()) {
					if (!ce.equals(s))
						edges.add(expressionToPrimitiveEdge(s, ce));
				}
			}
			// TODO - union in reverse direction - index first?

		}
		else if (s instanceof OWLRestriction<?>) {
			edges.add(restrictionToPrimitiveEdge((OWLRestriction<?>) s));
		}
		else if (s instanceof OWLObjectIntersectionOf) {
			for (OWLClassExpression ce : ((OWLObjectIntersectionOf)s).getOperands()) {
				edges.add(expressionToPrimitiveEdge(s,ce));
			}
		}
		else if (s instanceof OWLObjectUnionOf) {
			// do nothing in this direction
		}
		return edges;
	}
	
	public Set<OWLObject> getAllOWLObjects() {
		Set<OWLClass> cls = ontology.getClassesInSignature();
		Set<OWLNamedIndividual> ins = ontology.getIndividualsInSignature();
		Set<OWLObject> obs = new HashSet<OWLObject>();
		obs.addAll(cls);
		obs.addAll(ins);
		return obs;
	}
	
	public void cacheEdges() {
		edgeBySource = new HashMap<OWLObject,Set<OWLGraphEdge>>();
		edgeByTarget = new HashMap<OWLObject,Set<OWLGraphEdge>>();
		
		for (OWLObject s : getAllOWLObjects()) {
			if (!edgeBySource.containsKey(s))
				edgeBySource.put(s, new HashSet<OWLGraphEdge>());
			for (OWLGraphEdge edge : getOutgoingEdges(s)) {
				edgeBySource.get(s).add(edge);
				OWLObject t = edge.getTarget();
				if (!edgeByTarget.containsKey(t))
					edgeByTarget.put(t, new HashSet<OWLGraphEdge>());
				edgeByTarget.get(t).add(edge);
			}
		}
	}
	
	public  Set<OWLGraphEdge> getIncomingEdges(OWLObject t) {
		ensureEdgesCached();
		return edgeByTarget.get(t);
	}


	private void ensureEdgesCached() {
		if (edgeByTarget == null)
			cacheEdges();
		
	}



	/**
	 * e.g. R-some-B ==> <R-some-B,R,B>
	 */
	private OWLGraphEdge restrictionToPrimitiveEdge(OWLRestriction s) {
		OWLObjectPropertyExpression p = null;
		OWLObject t = null;
		OWLQuantifiedProperty.Quantifier q = null;
		if (s instanceof OWLObjectSomeValuesFrom) {
			t  = ((OWLObjectSomeValuesFrom)s).getFiller();
			p = (OWLObjectPropertyExpression) s.getProperty();
			q = OWLQuantifiedProperty.Quantifier.SOME;
		}
		return new OWLGraphEdge(s,t,p,q,ontology);
	}

	public OWLGraphEdge expressionToPrimitiveEdge(OWLObject s, OWLClassExpression t) {
		return new OWLGraphEdge(s,t,ontology);
	}
	
	/**
	 * given an edge (either asserted or a closure edge), translate this into
	 * an OWL class expression.
	 * this is the reverse translation of the one from an OWLOntology to an
	 * OWLGraph
	 */
	public OWLObject edgeToTargetExpression(OWLGraphEdge e) {
		return edgeToTargetExpression(e.getQuantifiedPropertyList().iterator(),e.getTarget());
	}
	private OWLObject edgeToTargetExpression(
			Iterator<OWLQuantifiedProperty> qpi, OWLObject t) {
		if (qpi.hasNext()) {
			OWLQuantifiedProperty qp = qpi.next();
			OWLObject t2 = edgeToTargetExpression(qpi,t);
			if (qp.isSubClassOf()) {
				return t2;
			}
			else if (qp.isSomeValuesFrom()) {
				return dataFactory.getOWLObjectSomeValuesFrom(qp.getProperty(), 
						(OWLClassExpression) t2);
			}
			else if (qp.isAllValuesFrom()) {
				return dataFactory.getOWLObjectAllValuesFrom(qp.getProperty(), 
						(OWLClassExpression) t2);
			}
			else {
				// TODO
				return null;
			}
		}
		else {
			return t;
		}
	}


	public String getLabel(OWLClass c) {
		OWLAnnotationProperty lap = dataFactory.getOWLAnnotationProperty(OWLRDFVocabulary.RDFS_LABEL.getIRI()); 
		for (OWLAnnotation a : c.getAnnotations(ontology,lap)) {
			if (a.getValue() instanceof OWLLiteral) {
				OWLLiteral val = (OWLLiteral) a.getValue();
				return val.getLiteral(); // return first - todo - check zero or one
			}
		}
		return null;
	}

	public Set<OWLIndividual> getInferredIndividuals(OWLClass c) {
		Set<OWLIndividual> ins = new HashSet<OWLIndividual>();
		for (OWLIndividual in : ontology.getIndividualsInSignature()) {
			for (OWLGraphEdge e : getEdgesBetween(in, c)) {
				List<OWLQuantifiedProperty> qps = e.getQuantifiedPropertyList();
				if (qps.size() == 1 && qps.get(0).isInstanceOf()) {
					ins.add(in);
					break;
				}
			}
		}
		return ins;
	}

	public OWLObject getOWLObjectByIdentifier(String id) {
		String[] parts = id.split(":", 2);
		String s = "http://purl.obolibrary.org/obo/"+parts[0]+"_"+parts[1];
		
		IRI iri = IRI.create(s);
		return dataFactory.getOWLClass(iri);
	}
	
	public OWLObject getOWLObject(String s) {
		IRI iri = IRI.create(s);
		return dataFactory.getOWLClass(iri);
	}


	

}
