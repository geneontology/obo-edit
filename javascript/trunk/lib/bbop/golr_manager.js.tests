////
//// Some unit testing for package golr_manager.js
////
//// Usage:
////    Command line: "js -f golr_manager.js.tests"
////    Interactive: "js -f golr_manager.js.tests -f -"
////

// Load testing.
load('test.js');
var mr_t = new bbop.test();

// Correct environment.
load('core.js');
load('logger.js');

// Get some test data as well.
// This defines "bbop.golr.golr_meta".
load('../../_data/golr_meta.js');
load('golr_conf.js');
load('golr_response.js');

load('registry.js');
load('golr_manager.js');

///
/// Start unit testing.
///

// bbop.golr.faux_ajax
// Verify that not working works.
(function(){
     var jq = new bbop.golr.faux_ajax();
     mr_t.is_same_atom(bbop.core.what_is(jq), 'bbop.golr.faux_ajax', "faux me");
     mr_t.is_same_atom(jq.ajax({}), null, 'not work 1');
     mr_t.is_same_atom(jq.parseJSON({}), "", 'not work 2');
 })();

// bbop.golr.manager - 1
(function(){

     // Absolute basics.
     var gconf = new bbop.golr.conf(bbop.golr.golr_meta);
     var gm = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);
     mr_t.is_same_atom(bbop.core.what_is(gm), 'bbop.golr.manager', "me");

     // Let's play a little like we did in the DrillExp.js demo.
     //var g = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);
     mr_t.is_same_atom(gm.get('rows'), 10, "default 10 rows");
     gm.set('rows', 100);
     mr_t.is_same_atom(gm.get('rows'), 100, "set/get 100 rows");

     // Does extra behave?
     var bits = "fq=-isa_partof_closure:[*%20TO%20*]";
     var url1 = gm.get_query_url();
     gm.set_extra(bits);
     var url2 = gm.get_query_url();
     gm.set_extra("");
     var url3 = gm.get_query_url();
     mr_t.is_different_atom(url1, url2, "not the same out of it");
     mr_t.is_string_embedded(url2, url1, '&' + bits, "set_extra adds");
     mr_t.is_same_atom(url1, url3, "set_extra resets");
     
 })();

// bbop.golr.manager - 2 - facets
(function(){

     // Setup.
     var gconf = new bbop.golr.conf(bbop.golr.golr_meta);
     var gm = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);

     // Let's play a little more...
     mr_t.is_same_set(gm.facets(), [], "no facets");
     gm.facets('foo');
     mr_t.is_same_set(gm.facets(), ['foo'], "one facet");
     mr_t.is_same_set(gm.facets('bar'), ['bar', 'foo'], "two facets");
     gm.set_personality('bbop_ann');
     mr_t.is_same_set(gm.facets(), ['source', 'evidence_type', 'taxon',
				    'isa_partof_label_closure',
				    'annotation_extension_class', 'type'],
		      "personality");
     gm.facets([]);
     mr_t.is_same_set(gm.facets(), [], "no facets again");
 })();

// bbop.golr.manager - 3 - simulation
(function(){

     // Setup.
     var gconf = new bbop.golr.conf(bbop.golr.golr_meta);
     var gm_ann = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);
     gm_ann.set_personality('bbop_ann'); // profile in gconf
     gm_ann.add_query_filter('document_category', 'annotation', ['+', '*']);
     gm_ann.add_query_filter('document_category', 'ontology_class', ['-']);
     gm_ann.add_query_filter('isa_partof_closure', 'GO:0022008', ['+', '*']);
     gm_ann.set_extra('foo=bar');

     mr_t.is_same_url(gm_ann.get_query_url(),
      		      'http://golr.berkeleybop.org/select?&qt=standard&indent=on&wt=json&rows=10&start=0&fl=*%2Cscore&facet=true&facet.mincount=1&json.nl=arrarr&facet.field=source&facet.field=evidence_type&facet.field=taxon&facet.field=isa_partof_label_closure&facet.field=annotation_extension_class&facet.field=type&fq=document_category:"annotation"&fq=-document_category:"ontology_class"&fq=isa_partof_closure:"GO:0022008"&foo=bar',
      		      "looks like the real thing");
 })();

// bbop.golr.manager - 4 - new fq handling
(function(){

     // Setup.
     var gconf = new bbop.golr.conf(bbop.golr.golr_meta);
     var gm_ann = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);

     gm_ann.add_query_filter('foo1', 'bar1a');
     gm_ann.add_query_filter('foo1', 'bar1b', ['+']);
     gm_ann.add_query_filter('foo2', 'bar2', ['-']);
     gm_ann.add_query_filter('foo3', 'bar3', ['+', '*']);
     gm_ann.add_query_filter('foo4', 'bar4', ['-', '*']);

     // Some helper functions to identify which of the filters we are
     // currently inspecting.
     function _is_1a(item){
	 var retval = false;
	 if( item['filter'] == 'foo1' && item['value'] == 'bar1a' &&
	     item['negative_p'] == false && item['sticky_p'] == false ){
		 retval = true;
	     }
	 return retval;
     }
     function _is_1b(item){
	 var retval = false;
	 if( item['filter'] == 'foo1' && item['value'] == 'bar1b' &&
	     item['negative_p'] == false && item['sticky_p'] == false ){
		 retval = true;
	     }
	 return retval;
     }
     function _is_2(item){
	 var retval = false;
	 if( item['filter'] == 'foo2' && item['value'] == 'bar2' &&
	     item['negative_p'] == true && item['sticky_p'] == false ){
		 retval = true;
	     }
	 return retval;
     }
     function _is_3(item){
	 var retval = false;
	 if( item['filter'] == 'foo3' && item['value'] == 'bar3' &&
	     item['negative_p'] == false && item['sticky_p'] == true ){
		 retval = true;
	     }
	 return retval;
     }
     function _is_4(item){
	 var retval = false;
	 if( item['filter'] == 'foo4' && item['value'] == 'bar4' &&
	     item['negative_p'] == true && item['sticky_p'] == true ){
		 retval = true;
	     }
	 return retval;
     }
     
     // And the test framer to easily weild the above tests.
     function test_frame_01(in_filters, func_test_list, msg_fragment){
	 bbop.core.each(in_filters,
			function(item, index){
			    mr_t.is_in_list_diy(item, func_test_list,
						function(in_item, list_func){
						    return list_func(in_item);
						},
						msg_fragment + index);
			});
     }
     
     // Okay, now loop through the initial filters to make sure they are
     // set correctly.
     test_frame_01(gm_ann.get_query_filters(),
		   [_is_1a, _is_1b, _is_2, _is_3, _is_4],
		   'tried inital filter add: ');
     
     // Try and get rid of the first and third keys.
     gm_ann.remove_query_filter('foo1', 'bar1a');
     gm_ann.remove_query_filter('foo2', 'bar2');
     test_frame_01(gm_ann.get_query_filters(),
		   [_is_1b, _is_3, _is_4],
		   'took out 2: ');
     
     // Probe just for the stickies.
     test_frame_01(gm_ann.get_sticky_query_filters(),
		   [_is_3, _is_4],
		   'just stickies: ');
     
     // Then see if we can get the non-stickies out.
     gm_ann.reset_query_filters();
     test_frame_01(gm_ann.get_query_filters(),
		   [_is_3, _is_4],
		   'only stickies left: ');
     
     var p4 = gm_ann.get_query_filter_properties('foo4', 'bar4');
     var p5 = gm_ann.get_query_filter_properties('foo5nope', 'bar5nothinghere');
     mr_t.is_true(_is_4(p4), 'I see foo4/bar4');
     mr_t.is_not_defined(p5, 'p5: there is nothing here');
 })();

// bbop.golr.manager - 5 - plist_to_property_hash
(function(){

     // Setup.
     var gconf = new bbop.golr.conf(bbop.golr.golr_meta);
     var gm_ann = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);

     // Possible property hashes.
     var p1 = {
	 'negative_p': true,
	 'sticky_p': true
     };
     var p2 = {
	 'negative_p': true,
	 'sticky_p': false
     };
     var p3 = {
	 'negative_p': false,
	 'sticky_p': false
     };
     var p4 = {
	 'negative_p': false,
	 'sticky_p': true
     };

     mr_t.is_same_hash(gm_ann.plist_to_property_hash(), p3,
		       'nothing default phash');
     mr_t.is_same_hash(gm_ann.plist_to_property_hash([]), p3,
		       'empty default phash');
     mr_t.is_same_hash(gm_ann.plist_to_property_hash(['+']), p3,
		       '+ default phash');
     mr_t.is_same_hash(gm_ann.plist_to_property_hash(['+', '$']), p3,
		       '+ $ default phash');
     mr_t.is_same_hash(gm_ann.plist_to_property_hash(['$']), p3,
		       '$ default phash');
     mr_t.is_same_hash(gm_ann.plist_to_property_hash(['-']), p2,
		       '- phash');
     mr_t.is_same_hash(gm_ann.plist_to_property_hash(['*']), p4,
		       '* phash');
     mr_t.is_same_hash(gm_ann.plist_to_property_hash(['-', '*']), p1,
		       '- * phash');

 })();

// bbop.golr.manager - 6 - paging
(function(){

     // Setup.
     var gconf = new bbop.golr.conf(bbop.golr.golr_meta);
     var gm_ann = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);
     gm_ann.set_personality('bbop_ann'); // profile in gconf

     mr_t.is_same_url(gm_ann.get_query_url(),
      		      'http://golr.berkeleybop.org/select?&qt=standard&indent=on&wt=json&rows=10&start=0&fl=*%2Cscore&facet=true&facet.mincount=1&json.nl=arrarr&facet.field=source&facet.field=evidence_type&facet.field=taxon&facet.field=isa_partof_label_closure&facet.field=annotation_extension_class&facet.field=type',
      		      "paging looks okay before");
     gm_ann.page(7, 11);
     mr_t.is_same_url(gm_ann.get_query_url(),
      		      'http://golr.berkeleybop.org/select?&qt=standard&indent=on&wt=json&rows=7&start=11&fl=*%2Cscore&facet=true&facet.mincount=1&json.nl=arrarr&facet.field=source&facet.field=evidence_type&facet.field=taxon&facet.field=isa_partof_label_closure&facet.field=annotation_extension_class&facet.field=type',
      		      "paging looks okay after");
     gm_ann.search();
     mr_t.is_same_url(gm_ann.get_query_url(),
      		      'http://golr.berkeleybop.org/select?&qt=standard&indent=on&wt=json&rows=10&start=0&fl=*%2Cscore&facet=true&facet.mincount=1&json.nl=arrarr&facet.field=source&facet.field=evidence_type&facet.field=taxon&facet.field=isa_partof_label_closure&facet.field=annotation_extension_class&facet.field=type',
      		      "paging resets properly");
 })();

// bbop.golr.manager - 7 - double filter simulation
(function(){

     // Setup.
     var gconf = new bbop.golr.conf(bbop.golr.golr_meta);
     var gm_ann = new bbop.golr.manager('http://golr.berkeleybop.org/', gconf);
     gm_ann.set_personality('bbop_ann'); // profile in gconf
     gm_ann.add_query_filter('document_category', 'annotation', ['-']);
     gm_ann.add_query_filter('document_category', 'ontology_class', ['-']);
     
     mr_t.is_same_url(gm_ann.get_query_url(),
      		      'http://golr.berkeleybop.org/select?&qt=standard&indent=on&wt=json&rows=10&start=0&fl=*%2Cscore&facet=true&facet.mincount=1&json.nl=arrarr&facet.field=source&facet.field=evidence_type&facet.field=taxon&facet.field=isa_partof_label_closure&facet.field=annotation_extension_class&facet.field=type&fq=-document_category:"annotation"&fq=-document_category:"ontology_class"',
      		      "looks like a correct double negative filter");
 })();

///
/// End unit testing.
///

// Final report.
mr_t.report();
